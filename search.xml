<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LLM学习】【Ollama】四、MCP</title>
      <link href="/2025/09/22/04_LLM_mcp/"/>
      <url>/2025/09/22/04_LLM_mcp/</url>
      
        <content type="html"><![CDATA[<h1 id="在-Ollama-多轮对话中集成-MCP，并将结果嵌入上下文"><a href="#在-Ollama-多轮对话中集成-MCP，并将结果嵌入上下文" class="headerlink" title="在 Ollama 多轮对话中集成 MCP，并将结果嵌入上下文"></a>在 Ollama 多轮对话中集成 MCP，并将结果嵌入上下文</h1><p>本文基于一个最小可用的 CLI 项目，演示如何在 Ollama 的多轮对话中集成 MCP（消息控制协议风格的指令），并把 MCP 的执行结果注入到对话历史里，让大模型在后续轮次中“记得”这些结果并可直接引用。</p><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_mcp">https://github.com/MiaoJieF/LLM_mcp</a></p></blockquote><h2 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h2><ul><li>持久化多轮对话上下文</li><li>识别并处理 MCP 指令：<code>/time</code> 和 <code>/bmi 身高 体重</code></li><li>将 MCP 执行结果写回对话历史，供模型后续引用</li><li>通过简单 CLI 进行交互</li></ul><h2 id="二、模块划分"><a href="#二、模块划分" class="headerlink" title="二、模块划分"></a>二、模块划分</h2><ul><li><code>ollama_client.py</code>：与 Ollama HTTP API 交互</li><li><code>mcp_handler.py</code>：解析与执行 MCP 指令（时间查询、BMI 计算）</li><li><code>conversation_manager.py</code>：维护对话上下文，路由 MCP 与普通对话，并把 MCP 结果写入历史</li><li><code>main.py</code>：命令行入口，设定系统提示、读取用户输入</li></ul><h2 id="三、MCP-的识别与执行"><a href="#三、MCP-的识别与执行" class="headerlink" title="三、MCP 的识别与执行"></a>三、MCP 的识别与执行</h2><p>MCP 的识别策略非常直观：所有以 <code>/</code> 开头的输入都作为候选 MCP 指令；具体支持的指令在 <code>mcp_handler.py</code> 中逐一匹配与处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def handle_mcp_command(user_text: str) -&gt; MCPResult:</span><br><span class="line">    text = user_text.strip()</span><br><span class="line">    if not text.startswith(&quot;/&quot;):</span><br><span class="line">        return MCPResult(handled=False)</span><br><span class="line"></span><br><span class="line">    if text.lower() == TIME_CMD:</span><br><span class="line">        now = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">        return MCPResult(handled=True, response=f&quot;当前时间：&#123;now&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    if text.lower().startswith(BMI_CMD):</span><br><span class="line">        try:</span><br><span class="line">            height_m, weight_kg = parse_bmi_args(text)</span><br><span class="line">            bmi = weight_kg / (height_m * height_m)</span><br><span class="line">            category = bmi_category(bmi)</span><br><span class="line">            return MCPResult(</span><br><span class="line">                handled=True,</span><br><span class="line">                response=(</span><br><span class="line">                    f&quot;BMI: &#123;bmi:.2f&#125;，状态：&#123;category&#125;&quot;</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line">        except Exception as exc:</span><br><span class="line">            return MCPResult(handled=True, response=f&quot;BMI 计算错误：&#123;exc&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    return MCPResult(handled=False)</span><br></pre></td></tr></table></figure><ul><li><code>/time</code>：直接返回当前系统时间。</li><li><code>/bmi</code>：解析参数（米、千克），计算 BMI 并给出健康状态。对格式错误、数值常识做了防御性校验。</li></ul><h2 id="四、将-MCP-结果嵌入对话历史"><a href="#四、将-MCP-结果嵌入对话历史" class="headerlink" title="四、将 MCP 结果嵌入对话历史"></a>四、将 MCP 结果嵌入对话历史</h2><p>关键在 <code>ConversationManager.process_input</code>。当检测到 MCP 命令被处理后，我们不仅把指令作为用户消息写入历史，还把“结构化的 MCP 结果”作为一次助手回复写回历史，带上统一的可识别前缀“（来自MCP）”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mcp: MCPResult = handle_mcp_command(user_text)</span><br><span class="line">if mcp.handled:</span><br><span class="line">    # 记录指令与结果到历史，便于模型后续引用</span><br><span class="line">    self.add_user_message(user_text)</span><br><span class="line">    mcp_response_text = mcp.response or &quot;&quot;</span><br><span class="line">    history_note = (</span><br><span class="line">        &quot;（来自MCP）\n&quot;</span><br><span class="line">        f&quot;指令：&#123;user_text&#125;\n&quot;</span><br><span class="line">        f&quot;结果：&#123;mcp_response_text&#125;&quot;</span><br><span class="line">    )</span><br><span class="line">    self.add_assistant_message(history_note)</span><br><span class="line">    return mcp_response_text</span><br></pre></td></tr></table></figure><p>为什么要以“助手消息”写回？</p><ul><li>因为多数 Chat 模型会把 <code>assistant</code> 角色视为“可被引用的已有事实”。</li><li>通过统一前缀“（来自MCP）”，我们还能在系统提示中明确告诉模型：这些是可信的工具结果。</li></ul><h2 id="五、系统提示（System-Prompt）的配合"><a href="#五、系统提示（System-Prompt）的配合" class="headerlink" title="五、系统提示（System Prompt）的配合"></a>五、系统提示（System Prompt）的配合</h2><p>系统提示负责为模型注入“如何看待 MCP 结果”的规则。在 <code>main.py</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">convo.add_system_message(</span><br><span class="line">    &quot;你是一个乐于助人的助手。回答时简洁、准确。\n&quot;</span><br><span class="line">    &quot;如果对话中出现以‘（来自MCP）’开头的内容，视为已执行的工具结果，&quot;</span><br><span class="line">    &quot;可直接引用其中的事实进行回答，不必重复计算或质疑其有效性。&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样，当用户后续追问“刚才的时间是多少？”、“我属于什么 BMI 状态？”时，模型会优先引用历史里标注为“（来自MCP）”的那条助手消息，得到稳定、一致的回答。</p><h2 id="六、与-Ollama-的集成"><a href="#六、与-Ollama-的集成" class="headerlink" title="六、与 Ollama 的集成"></a>六、与 Ollama 的集成</h2><p>与 Ollama 的交互通过 HTTP Chat API 完成：</p><ul><li>封装在 <code>OllamaClient.chat</code> 中，传入 <code>messages</code>（包含 system、user、assistant 历史）。</li><li>发生异常时统一抛出 <code>RuntimeError</code>，便于 CLI 层捕获与提示。</li></ul><h2 id="七、交互体验与容错"><a href="#七、交互体验与容错" class="headerlink" title="七、交互体验与容错"></a>七、交互体验与容错</h2><ul><li>CLI 会给出指令提示：<code>/time</code>、<code>/bmi 身高 体重</code>、<code>/exit</code>。</li><li>对 <code>/bmi</code> 的输入做了格式与范围校验，错误会以“BMI 计算错误：…”形式返回，同时仍会写入“来自MCP”的历史记录，方便追溯。</li></ul><h2 id="八、常见扩展点"><a href="#八、常见扩展点" class="headerlink" title="八、常见扩展点"></a>八、常见扩展点</h2><ul><li>更多 MCP 指令：如 <code>/weather 城市</code>、<code>/stock 代码</code>，只需在 <code>mcp_handler.py</code> 增加解析与处理，并复用现有的写回历史逻辑。</li><li>Streaming 输出：<code>OllamaClient.chat</code> 可切换 <code>stream=True</code>，并按块回显，同时仍把完整结果写回历史。</li><li>结构化结果：将 MCP 响应用 JSON 序列化写入历史，并在 system prompt 中说明“JSON 字段的语义”，提升模型引用的准确性。</li><li>只记录不回显：如果你不希望在屏幕上重复显示 MCP 结果，可修改 <code>process_input</code> 只写历史、不回显，或提供开关。</li></ul><h2 id="九、小结"><a href="#九、小结" class="headerlink" title="九、小结"></a>九、小结</h2><p>本文展示了一个简单而实用的模式：</p><ul><li>先在输入侧识别 MCP 指令</li><li>执行后把“带前缀的工具结果”作为助手消息写入历史</li><li>在系统提示中给予模型明确的“引用规则”</li></ul><p>通过这三步，模型不仅能在当下给出正确答复，更能在后续轮次中记住并稳定引用同一事实，显著提升混合“对话 + 工具”场景下的可用性与一致性。</p><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_mcp">https://github.com/MiaoJieF/LLM_mcp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LLM学习】【Ollama】三、RAG</title>
      <link href="/2025/09/22/03_LLM_rag/"/>
      <url>/2025/09/22/03_LLM_rag/</url>
      
        <content type="html"><![CDATA[<p>在大语言模型（LLM）应用中，检索增强生成（RAG）技术因其能让模型结合外部知识回答问题而备受关注。本文将结合一个简洁的开源项目，带你从零理解 RAG 的核心原理与实现方式，即使没有复杂的工程经验也能快速上手。</p><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_rag">https://github.com/MiaoJieF/LLM_rag</a></p></blockquote><h1 id="一、什么是-RAG？为什么需要它？​"><a href="#一、什么是-RAG？为什么需要它？​" class="headerlink" title="一、什么是 RAG？为什么需要它？​"></a>一、什么是 RAG？为什么需要它？​</h1><p>RAG（Retrieval-Augmented Generation，检索增强生成）是一种将 “检索外部知识” 与 “LLM 生成” 结合的技术。它解决了传统 LLM 的两大痛点：​</p><ul><li>知识时效性问题：LLM 训练数据有截止日期，无法回答最新信息​</li><li>知识准确性问题：避免模型 “一本正经地胡说八道”，答案可追溯到来源文档​</li></ul><p>简单来说，RAG 的工作流程可以概括为四步：​</p><ul><li>分块：将长文档切割成有重叠的小片段（保持语义完整）​</li><li>向量化：用嵌入模型将文本片段转换为向量（数字表示）​</li><li>检索：将用户问题转为向量，与文本向量做相似度匹配，找到最相关的片段​</li><li>生成：将问题和检索到的片段一起传给 LLM，生成基于参考文档的答案</li></ul><h1 id="二、一个极简的-RAG-实现：简易版-localGPT​"><a href="#二、一个极简的-RAG-实现：简易版-localGPT​" class="headerlink" title="二、一个极简的 RAG 实现：简易版 localGPT​"></a>二、一个极简的 RAG 实现：简易版 localGPT​</h1><p>今天要介绍的这个开源项目（项目结构）专为学习 RAG 原理设计，代码简洁易懂，无需复杂依赖即可本地运行。它的核心特点是：​</p><ul><li>纯离线运行：支持本地嵌入模型和本地 LLM（无需联网调用 API）​</li><li>轻量易上手：代码量少，模块划分清晰，适合初学者阅读​</li><li>功能完整：包含文档加载、分块、嵌入、检索、生成全流程</li></ul><h2 id="1-项目核心结构​"><a href="#1-项目核心结构​" class="headerlink" title="1. 项目核心结构​"></a>1. 项目核心结构​</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─ data/               <span class="comment"># TXT 文档（示例：sample.txt）</span></span><br><span class="line">├─ src/</span><br><span class="line">│  ├─ loader.py        <span class="comment"># 加载 .txt 文件</span></span><br><span class="line">│  ├─ chunker.py       <span class="comment"># 文本分块（定长+重叠）</span></span><br><span class="line">│  ├─ embeddings.py    <span class="comment"># Sentence-Transformers 嵌入（支持本地目录）</span></span><br><span class="line">│  ├─ vector_store.py  <span class="comment"># 内存向量库 + 余弦相似度检索 + 保存/加载</span></span><br><span class="line">│  ├─ retriever.py     <span class="comment"># 检索器（整合分块、嵌入、搜索）</span></span><br><span class="line">│  ├─ llm.py           <span class="comment"># 本地 LLM（llama.cpp 可选）+ Ollama 客户端（支持流式&amp;中文）</span></span><br><span class="line">│  └─ cli.py           <span class="comment"># 命令行入口（index / ask / chat）</span></span><br><span class="line">├─ tests/              <span class="comment"># 基础测试</span></span><br><span class="line">├─ requirements.txt    <span class="comment"># 依赖</span></span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><p>每个模块各司其职，通过简单的调用关系构成完整的 RAG 流程，非常适合逐模块学习。​</p><h2 id="2-核心功能解析​"><a href="#2-核心功能解析​" class="headerlink" title="2. 核心功能解析​"></a>2. 核心功能解析​</h2><h3 id="（1）文本分块：保持语义的关键​"><a href="#（1）文本分块：保持语义的关键​" class="headerlink" title="（1）文本分块：保持语义的关键​"></a>（1）文本分块：保持语义的关键​</h3><p>长文本直接处理会丢失上下文，项目通过chunker.py实现定长 + 重叠分块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心分块逻辑（src/chunker.py）</span></span><br><span class="line">def simple_chunk(text: str, chunk_size: int = 500, chunk_overlap: int = 100) -&gt; List[str]:</span><br><span class="line">    chunks = []</span><br><span class="line">    start_index = 0</span><br><span class="line">    step = chunk_size - chunk_overlap  <span class="comment"># 实际步长 = 块大小 - 重叠部分</span></span><br><span class="line">    <span class="keyword">while</span> start_index &lt; len(text):</span><br><span class="line">        end_index = min(start_index + chunk_size, len(text))</span><br><span class="line">        chunk = text[start_index:end_index].strip()</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            chunks.append(chunk)</span><br><span class="line">        start_index += step</span><br><span class="line">    <span class="built_in">return</span> chunks</span><br></pre></td></tr></table></figure><p>分块参数建议：​</p><ul><li>chunk_size：300~800 字符（根据文档密度调整）​</li><li>chunk_overlap：50~200 字符（确保上下文连贯）​</li></ul><h3 id="（2）向量化：文本转向量的魔法​"><a href="#（2）向量化：文本转向量的魔法​" class="headerlink" title="（2）向量化：文本转向量的魔法​"></a>（2）向量化：文本转向量的魔法​</h3><p>项目使用 Sentence-Transformers 的all-MiniLM-L6-v2模型（轻量且效果好），通过embeddings.py实现文本向量化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量生成示例（src/embeddings.py）</span></span><br><span class="line">class EmbeddingModel:</span><br><span class="line">    def __init__(self, model_name: str = <span class="string">&quot;all-MiniLM-L6-v2&quot;</span>):</span><br><span class="line">        self.model = SentenceTransformer(model_name)</span><br><span class="line">    </span><br><span class="line">    def embed_documents(self, texts: List[str]) -&gt; np.ndarray:</span><br><span class="line">        <span class="comment"># 将文本列表转为向量矩阵</span></span><br><span class="line">        <span class="built_in">return</span> self.model.encode(texts, convert_to_numpy=True)</span><br><span class="line">    </span><br><span class="line">    def embed_query(self, text: str) -&gt; np.ndarray:</span><br><span class="line">        <span class="comment"># 将单个问题转为向量</span></span><br><span class="line">        <span class="built_in">return</span> self.model.encode([text], convert_to_numpy=True)[0]</span><br></pre></td></tr></table></figure><p>支持本地离线加载模型：只需下载模型文件到本地，通过路径指定即可避免联网。​</p><h3 id="（3）向量检索：快速找到相关片段​"><a href="#（3）向量检索：快速找到相关片段​" class="headerlink" title="（3）向量检索：快速找到相关片段​"></a>（3）向量检索：快速找到相关片段​</h3><p>向量存储在vector_store.py中实现，核心是余弦相似度计算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 余弦相似度检索（src/vector_store.py）</span></span><br><span class="line">def cosine_similarity(a: np.ndarray, b: np.ndarray) -&gt; np.ndarray:</span><br><span class="line">    <span class="built_in">return</span> a @ b.T  <span class="comment"># 矩阵乘法等价于余弦相似度（已归一化向量）</span></span><br><span class="line"></span><br><span class="line">class InMemoryVectorStore:</span><br><span class="line">    def search(self, query_vector: np.ndarray, top_k: int = 4) -&gt; List[Tuple[str, <span class="built_in">float</span>]]:</span><br><span class="line">        scores = cosine_similarity(self.embeddings, query_vector.reshape(1, -1)).reshape(-1)</span><br><span class="line">        idx = np.argsort(-scores)[:top_k]  <span class="comment"># 取分数最高的前k个</span></span><br><span class="line">        <span class="built_in">return</span> [(self.texts[i], <span class="built_in">float</span>(scores[i])) <span class="keyword">for</span> i <span class="keyword">in</span> idx]</span><br></pre></td></tr></table></figure><h3 id="（4）答案生成：结合知识的智能回答​"><a href="#（4）答案生成：结合知识的智能回答​" class="headerlink" title="（4）答案生成：结合知识的智能回答​"></a>（4）答案生成：结合知识的智能回答​</h3><p>生成模块llm.py支持三种模式：​</p><ul><li>启发式回答：无 LLM 时可用，直接从检索结果中提取相关句子​</li><li>llama.cpp 本地模型：支持.gguf格式模型，完全离线运行​</li><li>Ollama 客户端：支持多轮对话和流式输出，对中文友好</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示词构建（src/llm.py）</span></span><br><span class="line">def build_prompt(question: str, contexts: List[str]) -&gt; str:</span><br><span class="line">    context_block = <span class="string">&quot;\n\n&quot;</span>.<span class="built_in">join</span>(f<span class="string">&quot;[Document &#123;i+1&#125;]\n&#123;c&#125;&quot;</span> <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(contexts))</span><br><span class="line">    <span class="built_in">return</span> f<span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    请根据以下上下文回答问题，若答案不在上下文中请说明不知道。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    上下文：</span></span><br><span class="line"><span class="string">    &#123;context_block&#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">    答案：</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三、快速上手：3-步实现本地文档问答"><a href="#三、快速上手：3-步实现本地文档问答" class="headerlink" title="三、快速上手：3 步实现本地文档问答"></a>三、快速上手：3 步实现本地文档问答</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目（假设已获取仓库地址）</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/MiaoJieF/LLM_rag.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> LLM_rag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>依赖说明：</p><ul><li><p><code>sentence-transformers</code>：用于生成文本向量</p></li><li><p><code>numpy</code>：向量计算</p></li><li><p><code>llama-cpp-python</code>：可选，用于本地 LLM 推理</p></li><li><p><code>requests</code>：Ollama 客户端依赖</p></li></ul><h2 id="2-构建索引（分块-向量化-存储）"><a href="#2-构建索引（分块-向量化-存储）" class="headerlink" title="2. 构建索引（分块 + 向量化 + 存储）"></a>2. 构建索引（分块 + 向量化 + 存储）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将data目录下的TXT文档构建索引</span></span><br><span class="line"></span><br><span class="line">python -m src.cli index --data_dir data --index_path index.pkl --chunk_size 500 --chunk_overlap 100</span><br></pre></td></tr></table></figure><p>执行后会生成<code>index.pkl</code>文件，包含所有文档的向量和文本片段。</p><h2 id="3-开始问答"><a href="#3-开始问答" class="headerlink" title="3. 开始问答"></a>3. 开始问答</h2><h3 id="单轮问答："><a href="#单轮问答：" class="headerlink" title="单轮问答："></a>单轮问答：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m src.cli ask --index_path index.pkl --question <span class="string">&quot;贵宾客户有哪些权益？&quot;</span> --top_k 4 --show_context</span><br></pre></td></tr></table></figure><h3 id="多轮对话："><a href="#多轮对话：" class="headerlink" title="多轮对话："></a>多轮对话：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装Ollama并拉取模型：ollama pull gemma3:1b</span></span><br><span class="line">python -m src.cli chat --index_path index.pkl --top_k 4 --show_context --ollama_model gemma3:1b --ollama_base_url http://127.0.0.1:11434</span><br></pre></td></tr></table></figure><h1 id="四、常见问题与进阶技巧"><a href="#四、常见问题与进阶技巧" class="headerlink" title="四、常见问题与进阶技巧"></a>四、常见问题与进阶技巧</h1><ol><li><p><strong>中文乱码问题</strong>：Windows 下可先执行<code>chcp 65001</code>切换编码，或使用 VSCode 终端</p></li><li><p><strong>本地模型路径设置</strong>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌入模型本地路径</span></span><br><span class="line"><span class="built_in">export</span> EMBEDDING\_MODEL=<span class="string">&quot;E:/models/all-MiniLM-L6-v2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># llama.cpp模型路径</span></span><br><span class="line"><span class="built_in">export</span> LLAMA\_CPP\_MODEL=<span class="string">&quot;E:/models/your\_model.gguf&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>分块参数调优</strong>：</li></ol><ul><li>长文档（如论文）：chunk_size&#x3D;800，overlap&#x3D;200</li><li>短文本（如问答库）：chunk_size&#x3D;300，overlap&#x3D;50</li></ul><ol start="4"><li><strong>检索效果优化</strong>：</li></ol><ul><li>增加<code>top_k</code>值（如 6）可获取更多上下文</li><li>尝试不同的嵌入模型（如<code>paraphrase-multilingual-MiniLM-L12-v2</code>支持多语言）</li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>这个简易版 localGPT 项目以 “最小可行” 的方式展示了 RAG 的核心流程，非常适合初学者理解检索增强生成的工作原理。通过逐模块阅读代码，你可以掌握：</p><ul><li><p>如何将文本转换为可计算的向量</p></li><li><p>如何通过向量相似度找到相关知识</p></li><li><p>如何让 LLM 基于参考文档生成可靠答案</p></li></ul><p>RAG 技术的应用远不止文档问答，还可以扩展到知识库构建、智能客服、代码助手等场景。动手实践这个项目，相信能为你深入学习 LLM 应用打下坚实基础。</p><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_rag">https://github.com/MiaoJieF/LLM_rag</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LLM学习】【Ollama】二、微调</title>
      <link href="/2025/09/22/02_LLM_finetune/"/>
      <url>/2025/09/22/02_LLM_finetune/</url>
      
        <content type="html"><![CDATA[<p>在大语言模型（LLM）应用中，如何在有限资源下实现模型的领域适配是一个关键问题。LoRA（Low-Rank Adaptation）技术作为参数高效微调的代表，通过冻结预训练模型权重并注入可训练的低秩矩阵，在大幅减少参数量的同时保持良好性能。本文基于开源项目<a href="https://github.com/MiaoJieF/LLM_finetune">LLM_finetune</a>，详细介绍如何使用 LoRA 技术对 Gemma 模型进行银行领域微调，包含完整流程与实操指南。</p><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_finetune">https://github.com/MiaoJieF/LLM_finetune</a></p></blockquote><h1 id="一、项目概述"><a href="#一、项目概述" class="headerlink" title="一、项目概述"></a>一、项目概述</h1><p>LLM_finetune是一个专注于 Gemma 模型 LoRA 微调的完整工具链，专为银行领域场景优化。项目提供从数据集构建到模型部署的全流程支持，核心特点包括：</p><ul><li>轻量级：采用 LoRA 技术，仅训练少量参数（相比全量微调减少 90% 以上参数量）</li><li>专业性：内置银行领域数据集与评估体系</li><li>易用性：提供一键式脚本与详细配置说明</li><li>完整性：涵盖数据处理、训练、评估、对话交互全流程</li></ul><p>项目文件结构清晰，核心组件包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── banking_dataset.py      <span class="comment"># 银行领域数据集生成</span></span><br><span class="line">├── lora_finetune.py       <span class="comment"># LoRA微调核心脚本</span></span><br><span class="line">├── chat_with_model.py      <span class="comment"># 交互式对话工具</span></span><br><span class="line">├── compare_models.py       <span class="comment"># 微调前后效果对比</span></span><br><span class="line">└── quick_start.py         <span class="comment"># 一键式流程脚本</span></span><br></pre></td></tr></table></figure><h1 id="二、LoRA-微调核心技术解析"><a href="#二、LoRA-微调核心技术解析" class="headerlink" title="二、LoRA 微调核心技术解析"></a>二、LoRA 微调核心技术解析</h1><h2 id="1-LoRA-原理与优势"><a href="#1-LoRA-原理与优势" class="headerlink" title="1. LoRA 原理与优势"></a>1. LoRA 原理与优势</h2><p>LoRA 通过在模型关键层（如注意力模块）插入低秩矩阵分解参数，实现参数高效微调：</p><ul><li>冻结预训练模型权重，避免灾难性遗忘</li><li>仅训练低秩矩阵参数（通常数十万级），大幅降低计算资源需求</li><li>训练完成后可将低秩矩阵合并回原模型，不影响推理效率</li><li>在银行领域场景中，这种方式既能保留 Gemma 模型的通用能力，又能高效学习领域知识。</li></ul><h2 id="2-核心配置参数"><a href="#2-核心配置参数" class="headerlink" title="2. 核心配置参数"></a>2. 核心配置参数</h2><p>项目中 LoRA 的关键配置如下（定义于lora_finetune.py）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lora_config = &#123;</span><br><span class="line">    <span class="string">&quot;r&quot;</span>: <span class="number">8</span>,                    <span class="comment"># 低秩矩阵的秩，控制参数量与表达能力</span></span><br><span class="line">    <span class="string">&quot;lora_alpha&quot;</span>: <span class="number">32</span>,          <span class="comment"># 缩放参数，通常设为r的2-4倍</span></span><br><span class="line">    <span class="string">&quot;target_modules&quot;</span>: [        <span class="comment"># 目标微调模块（Gemma注意力关键组件）</span></span><br><span class="line">        <span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;v_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, <span class="string">&quot;o_proj&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gate_proj&quot;</span>, <span class="string">&quot;up_proj&quot;</span>, <span class="string">&quot;down_proj&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;lora_dropout&quot;</span>: <span class="number">0.1</span>,        <span class="comment"># Dropout防止过拟合</span></span><br><span class="line">    <span class="string">&quot;bias&quot;</span>: <span class="string">&quot;none&quot;</span>,           <span class="comment"># 不微调偏置参数</span></span><br><span class="line">    <span class="string">&quot;task_type&quot;</span>: <span class="string">&quot;CAUSAL_LM&quot;</span>   <span class="comment"># 因果语言建模任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>训练参数配置：</p><ul><li>训练轮数（epochs）：建议 3-20（银行领域小数据集推荐 5-10）</li><li>批次大小（batch_size）：根据 GPU 显存调整（4-16）</li><li>学习率：2e-4（LoRA 通常使用比全量微调更高的学习率）</li><li>最大序列长度：512 tokens（覆盖银行问答场景需求）</li></ul><h1 id="三、完整实操流程"><a href="#三、完整实操流程" class="headerlink" title="三、完整实操流程"></a>三、完整实操流程</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p><strong>前置条件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python 3.8+</span><br><span class="line">建议 GPU 显存 6GB 以上（支持 CUDA 11.8+）</span><br><span class="line">16GB 以上内存，10GB 以上存储空间</span><br></pre></td></tr></table></figure><p><strong>依赖安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>核心依赖包括：PyTorch、Transformers、PEFT、Datasets 等。</p><p><strong>模型准备</strong><br>在<a href="https://huggingface.co/google/gemma-3-1b-pt/tree/main">Hugging Face</a>下载模型文件，将 Gemma-1B 模型文件放置于models&#x2F;gemma3-1b&#x2F;目录，需包含：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.json：模型配置文件</span><br><span class="line">tokenizer.json：分词器文件</span><br><span class="line">model.safetensors：模型权重文件</span><br></pre></td></tr></table></figure><h2 id="2-一键式微调流程"><a href="#2-一键式微调流程" class="headerlink" title="2. 一键式微调流程"></a>2. 一键式微调流程</h2><p>对于新手用户，推荐使用quick_start.py脚本完成全流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python quick_start.py</span><br></pre></td></tr></table></figure><p>该脚本自动执行以下步骤：</p><ol><li>生成银行领域数据集（16 组专业问答对）</li><li>执行 LoRA 微调（输出至outputs&#x2F;lora_banking_时间戳&#x2F;）</li><li>对比基础模型与微调模型效果</li><li>生成评估报告（comparison_results_*.json）</li></ol><h2 id="3-分步执行"><a href="#3-分步执行" class="headerlink" title="3. 分步执行"></a>3. 分步执行</h2><p><strong>步骤 1：创建数据集</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python banking_dataset.py</span><br></pre></td></tr></table></figure><p>生成的数据集包含银行常见场景问答，如账户开户、转账流程、理财产品等，自动划分为训练集（80%）与验证集（20%）。</p><p><strong>步骤 2：执行 LoRA 微调</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python lora_finetune.py \</span><br><span class="line">  --model-path models/gemma3-1b \</span><br><span class="line">  --output-dir outputs/lora_banking \</span><br><span class="line">  --epochs 10 \</span><br><span class="line">  --batch-size 8 \</span><br><span class="line">  --learning-rate 2e-4</span><br></pre></td></tr></table></figure><p>训练过程中会自动保存：</p><ul><li>LoRA 适配器参数</li><li>分词器配置</li><li>训练日志与评估指标</li></ul><p><strong>步骤 3：模型对比测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python compare_models.py \</span><br><span class="line">  --peft-model-path outputs/lora_banking \</span><br><span class="line">  --base-model-path models/gemma3-1b \</span><br><span class="line">  --output-file comparison_results.json</span><br></pre></td></tr></table></figure><p>对比指标包括：</p><ul><li>关键词匹配率（专业术语准确率）</li><li>回答完整性评分</li><li>响应时间</li><li>综合效果评分</li></ul><p><strong>步骤 4：交互式对话</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python chat_with_model.py --model-path outputs/lora_banking</span><br></pre></td></tr></table></figure><p>支持流式输出，可直接测试微调后模型在银行场景的问答效果。</p><h1 id="四、微调效果"><a href="#四、微调效果" class="headerlink" title="四、微调效果"></a>四、微调效果</h1><p><img src="/images/02_1.png" alt="在这里插入图片描述"><br><img src="/images/02_2.png" alt="在这里插入图片描述"></p><h1 id="五、TODO"><a href="#五、TODO" class="headerlink" title="五、TODO"></a>五、TODO</h1><ul><li>将微调得到的LORA模型参数和Ollama模型结合创建新模型，通过Ollama直接调用</li></ul><blockquote><p>项目地址：<a href="https://github.com/MiaoJieF/LLM_finetune">https://github.com/MiaoJieF/LLM_finetune</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LLM学习】【Ollama】一、本地运行与API调用</title>
      <link href="/2025/09/17/01_LLM_connect/"/>
      <url>/2025/09/17/01_LLM_connect/</url>
      
        <content type="html"><![CDATA[<h1 id="一、LLM-核心认知：从技术到应用"><a href="#一、LLM-核心认知：从技术到应用" class="headerlink" title="一、LLM 核心认知：从技术到应用"></a>一、LLM 核心认知：从技术到应用</h1><h2 id="1-技术原理：LLM-的-“底层骨架”-与-“训练密码”​"><a href="#1-技术原理：LLM-的-“底层骨架”-与-“训练密码”​" class="headerlink" title="1. 技术原理：LLM 的 “底层骨架” 与 “训练密码”​"></a>1. 技术原理：LLM 的 “底层骨架” 与 “训练密码”​</h2><p>LLM 的能力源于「架构设计」与「训练方法」的双重革新，核心目标是平衡 “模型规模” 与 “运行效率”：</p><h4 id="（1）核心架构：突破性能瓶颈的-3-大技术"><a href="#（1）核心架构：突破性能瓶颈的-3-大技术" class="headerlink" title="（1）核心架构：突破性能瓶颈的 3 大技术"></a>（1）核心架构：突破性能瓶颈的 3 大技术</h4><ul><li><p><strong>Transformer 架构：LLM 的 “地基”</strong><br>传统循环神经网络（RNN）需按文本顺序逐字处理，如同 “读句子只能从头读到尾”；而 Transformer 通过「自注意力机制」，可同时关注文本中所有词的关联（比如 “猫” 和 “抓老鼠” 的逻辑关系），实现 “全局上下文理解”，且支持并行计算（多 GPU 同时训练），为大规模模型奠定基础。</p></li><li><p><strong>超长上下文窗口：处理 “长篇文档” 的关键</strong><br>2025 年英伟达的 4M token 突破（约 300 万字，相当于 2 本《红楼梦》），核心依赖「YaRN-based RoPE 缩放技术」：</p><ul><li><p>先通过 “持续预训练” 让模型适应长文本；</p></li><li><p>再通过 “指令微调” 强化推理能力（避免 “读长文忘前文”）。</p><ul><li>对比：2023 年主流模型仅支持 128K token（约 9.6 万字），4M 突破让法律合同、科研论文的 “全文分析” 成为可能。</li></ul></li></ul></li><li><p><strong>混合专家（MoE）架构：效率革命的核心</strong><br>传统模型训练 &#x2F; 推理需激活全部参数（如 1750 亿参数模型每次都要调用 1750 亿），而 MoE 架构如同 “医院分科”—— 总参数庞大（如 Llama 4 的 2 万亿），但每次仅激活 “对应任务的专家模块”（如文本生成激活 2880 亿参数），通过「动态路由机制」（判断任务类型，分配对应 “专家”）降低计算成本。<br>国产案例：腾讯混元通过 “共享专家” 机制，800 亿总参数仅激活 130 亿，同时支持 25.6 万 token 上下文。</p></li></ul><h4 id="（2）训练流程：“预训练-微调”-的两段式逻辑"><a href="#（2）训练流程：“预训练-微调”-的两段式逻辑" class="headerlink" title="（2）训练流程：“预训练 + 微调” 的两段式逻辑"></a>（2）训练流程：“预训练 + 微调” 的两段式逻辑</h4><table><thead><tr><th>阶段</th><th>目标</th><th>数据特点</th><th>2025 年优化方向</th></tr></thead><tbody><tr><td>预训练</td><td>学习通用语言规律</td><td>海量无标注文本（万亿级）</td><td>提升数据质量（过滤低质内容）</td></tr><tr><td>微调</td><td>优化特定任务性能</td><td>高质量标注数据（百万级）</td><td>缩短训练时间（英伟达 H100 集群 5 小时训 1M 上下文模型）</td></tr></tbody></table><p><strong>节能技术补充</strong>：动态早期退出（Early Exiting）—— 模型生成简单内容（如 “今天天气如何”）时，仅用前几层网络计算；生成复杂内容（如代码）时再用完整网络，推理能耗降低 30%+。</p><h2 id="2-发展历程：从-“参数竞赛”-到-“生态分化”"><a href="#2-发展历程：从-“参数竞赛”-到-“生态分化”" class="headerlink" title="2. 发展历程：从 “参数竞赛” 到 “生态分化”"></a>2. 发展历程：从 “参数竞赛” 到 “生态分化”</h2><table><thead><tr><th>阶段</th><th>时间范围</th><th>核心特征</th><th>代表模型</th><th>关键突破</th></tr></thead><tbody><tr><td>萌芽期</td><td>2019-2022</td><td>参数规模快速扩张</td><td>GPT-2（16.1 亿）、GPT-3（1750 亿）</td><td>首次展现 “涌现能力”（参数超一定规模后能力质变）</td></tr><tr><td>开源爆发期</td><td>2023-2024</td><td>打破闭源壁垒</td><td>LLaMA 2（70 亿）、Mistral（7B）</td><td>平民化部署（消费级 GPU 可运行 7B 模型）</td></tr><tr><td>多元化竞争期</td><td>2025</td><td>效率优化 + 区域特色</td><td>Llama 3.3、ERNIE 4.5（4240 亿）、混元（800 亿）</td><td>4M 上下文、多模态融合、国产模型崛起</td></tr></tbody></table><p>LLM 的能力源于「架构设计」与「训练方法」的双重革新，核心目标是平衡 “模型规模” 与 “运行效率”：</p><h2 id="3-关键挑战与未来趋势"><a href="#3-关键挑战与未来趋势" class="headerlink" title="3. 关键挑战与未来趋势"></a>3. 关键挑战与未来趋势</h2><h4 id="（1）未解决的核心痛点（加示例更易理解）"><a href="#（1）未解决的核心痛点（加示例更易理解）" class="headerlink" title="（1）未解决的核心痛点（加示例更易理解）"></a>（1）未解决的核心痛点（加示例更易理解）</h4><ul><li><p><strong>幻觉问题</strong>：生成 “看似合理但错误” 的内容，如医疗模型将 “布洛芬用量” 错写为 “每日 5 次”（实际建议 3 次），在高精度领域（法律 &#x2F; 医疗）风险极高；</p></li><li><p><strong>监管碎片化</strong>：欧盟要求公开训练数据来源（推高成本），美国侧重自律，中国需政府备案，跨国企业合规成本增加；</p></li><li><p><strong>能耗与垄断</strong>：ChatGPT 每日推理能耗 564 兆瓦时（相当于 44 个 GPT-3 预训练能耗），且高性能模型研发需千亿级算力，中小团队难以参与。</p></li></ul><h4 id="（2）2025-未来方向"><a href="#（2）2025-未来方向" class="headerlink" title="（2）2025 + 未来方向"></a>（2）2025 + 未来方向</h4><ul><li><p><strong>技术突破</strong>：上下文窗口向 10M token 迈进（支持完整学术专著分析），边缘部署（手机 &#x2F; 平板运行 7B 模型）；</p></li><li><p><strong>生态分化</strong>：通用模型（如 Llama 3.3）做基础工具，垂直模型（如 “医疗 LLM”“法律 LLM”）做专业深度；</p></li><li><p><strong>治理落地</strong>：区域性认证体系成型（如欧盟 AI 认证），平衡 “创新” 与 “安全”。</p></li></ul><h1 id="二、Ollama简介"><a href="#二、Ollama简介" class="headerlink" title="二、Ollama简介"></a>二、Ollama简介</h1><p>Ollama 是一款开源的跨平台大语言模型部署工具，致力于让开发者和研究者在本地设备便捷运行大型语言模型（LLM），其核心使命是通过技术创新打破算力垄断，实现 AI 能力的民主化。以下从核心功能、技术优势、应用场景等维度展开介绍：</p><h2 id="1-极简部署体验"><a href="#1-极简部署体验" class="headerlink" title="1. 极简部署体验"></a>1. 极简部署体验</h2><p>采用类似 Docker 的容器化理念，用户通过简单命令（如ollama run llama3）即可一键下载并运行模型，自动处理环境配置与依赖安装，无需手动管理模型权重或复杂参数。支持 Llama、Mistral、Qwen 等 30 + 主流开源模型，覆盖从 7B 到 405B 参数规模，适配消费级显卡（如 7B 模型可在普通 GPU 流畅运行）。</p><h2 id="2-多模态与高性能优化"><a href="#2-多模态与高性能优化" class="headerlink" title="2. 多模态与高性能优化"></a>2. 多模态与高性能优化</h2><ul><li>技术架构：融合容器化部署与 AI 模型优化技术，独创分层量化技术（如 4-bit 量化）显著降低显存需求，增量加载机制减少内存占用，13B 模型仅需 16GB 内存即可启动。</li><li>多模态支持：兼容文本、代码、图像混合输入，支持长文本处理（单次对话 8k token 上下文），满足复杂场景需求。</li><li>性能升级：最新版本 v0.11.8 默认启用 Flash Attention，提升长序列推理效率；优化 GGUF 模型加载速度，减少内存碎片，并支持 AMD 显卡加速。</li></ul><h2 id="3-开发者友好工具链"><a href="#3-开发者友好工具链" class="headerlink" title="3. 开发者友好工具链"></a>3. 开发者友好工具链</h2><ul><li>API 与 SDK：提供 OpenAI 兼容的 REST API 及 Python&#x2F;JavaScript SDK，无缝对接 - LangChain 等框架，方便集成至企业级应用。</li><li>安全与版本控制：内置安全沙箱隔离运行环境，支持模型版本回溯与差异更新，保障数据隐私。</li></ul><h1 id="三、Ollama安装"><a href="#三、Ollama安装" class="headerlink" title="三、Ollama安装"></a>三、Ollama安装</h1><ul><li>官网下载：<a href="https://ollama.com/">https://ollama.com/</a></li><li>安装好后可在客户端中打开运行，也可在cmd中查看</li><li>打开cmd，输入</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="literal">--version</span></span><br></pre></td></tr></table></figure><p><img src="/images/01_1.png" alt="在这里插入图片描述"></p><ul><li>通过<code>ollama run &lt;model&gt;</code>运行大模型</li></ul><p><img src="/images/01_2.png" alt="在这里插入图片描述"></p><h1 id="四、Ollama常用命令"><a href="#四、Ollama常用命令" class="headerlink" title="四、Ollama常用命令"></a>四、Ollama常用命令</h1><ol><li>搜索远程仓库中支持的模型</li></ol><p>官网地址：<a href="https://ollama.com/library">https://ollama.com/library</a></p><ol start="3"><li>查看本地已下载的模型</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama list</span><br></pre></td></tr></table></figure><ol start="4"><li>下载并运行模型</li></ol><p>自动下载（若本地没有）并启动模型交互：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run &lt;模型名[:标签]&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除本地模型</li></ol><p>清理不需要的模型以释放空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama <span class="built_in">rm</span> &lt;模型名[:标签]&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>查看模型详细配置</li></ol><p>显示模型的参数、系统提示等信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama show &lt;模型名&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>非交互式生成内容</li></ol><p>直接输入提示词，让模型生成结果后退出（适合脚本或批量处理）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama generate &lt;模型名&gt; <span class="string">&quot;你的提示词&quot;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>结构化对话（JSON 输出）</li></ol><p>以 JSON 格式输出对话内容，方便程序解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama chat &lt;模型名&gt; --format json</span><br></pre></td></tr></table></figure><ol start="8"><li>设置推理参数</li></ol><p>临时调整模型生成参数（如温度、上下文长度等）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run &lt;模型名&gt; -- &lt;参数名&gt; &lt;值&gt;</span><br></pre></td></tr></table></figure><p>示例：ollama run llama3 – temperature 0.3（降低随机性，使输出更确定）。</p><ol start="9"><li>启动 &#x2F; 停止 Ollama 服务</li></ol><p>部分系统（如 Linux）需手动控制后台服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">ollama serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务（在另一个终端执行，或用kill命令）</span></span><br><span class="line">pkill ollama</span><br></pre></td></tr></table></figure><ol start="10"><li>查看服务状态<br>检查 Ollama 服务是否在运行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS</span></span><br><span class="line">ps aux | grep ollama</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows（PowerShell）</span></span><br><span class="line">Get-Process ollama</span><br></pre></td></tr></table></figure><ol start="11"><li>获取命令帮助</li></ol><p>查看所有命令或单个命令的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有命令</span></span><br><span class="line">ollama <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个命令的详细说明（如run）</span></span><br><span class="line">ollama <span class="built_in">help</span> run</span><br></pre></td></tr></table></figure><ol start="12"><li>导出 &#x2F; 导入模型（备份）</li></ol><p>将本地模型导出为文件（用于迁移或备份）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出</span></span><br><span class="line">ollama <span class="built_in">export</span> &lt;模型名&gt; &lt;导出路径&gt;</span><br><span class="line"><span class="comment"># 示例：ollama export llama3 ./llama3-backup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入</span></span><br><span class="line">ollama import &lt;新模型名&gt; &lt;导出文件路径&gt;</span><br></pre></td></tr></table></figure><p>示例：ollama import my-llama .&#x2F;llama3-backup</p><h1 id="五、API-调用"><a href="#五、API-调用" class="headerlink" title="五、API 调用"></a>五、API 调用</h1><ul><li><p>Ollama 提供了 HTTP API，可以通过编程方式调用模型。默认 API 地址为<a href="http://localhost:11434。">http://localhost:11434。</a></p></li><li><p>设置模型路径</p></li></ul><p>如果在客户端修改了模型保存路径，需要先在cmd中修改路径（仅在本次运行中生效）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMD 中</span></span><br><span class="line"><span class="built_in">set</span> OLLAMA_MODELS=E:\Ollama_models</span><br></pre></td></tr></table></figure><ul><li>启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">ollama serve</span><br></pre></td></tr></table></figure><h2 id="1-Python调用实例"><a href="#1-Python调用实例" class="headerlink" title="1. Python调用实例"></a>1. Python调用实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_ollama</span>(<span class="params">prompt, model=<span class="string">&quot;gemma3:1b&quot;</span></span>):</span><br><span class="line">    url = <span class="string">&quot;http://localhost:11434/api/generate&quot;</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;model&quot;</span>: model,</span><br><span class="line">        <span class="string">&quot;prompt&quot;</span>: prompt,</span><br><span class="line">        <span class="string">&quot;stream&quot;</span>: <span class="literal">False</span>  <span class="comment"># 非流式输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.post(url, json=payload)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        result = json.loads(response.text)</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&quot;response&quot;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;请求失败: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    prompt = <span class="string">&quot;请简要介绍一下机器学习的基本概念&quot;</span></span><br><span class="line">    response = call_ollama(prompt)</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure><h2 id="2-流式输出示例："><a href="#2-流式输出示例：" class="headerlink" title="2. 流式输出示例："></a>2. 流式输出示例：</h2><p>如果需要实时获取模型输出（如聊天应用），可以使用流式输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stream_ollama</span>(<span class="params">prompt, model=<span class="string">&quot;gemma3:1b&quot;</span></span>):</span><br><span class="line">    url = <span class="string">&quot;http://localhost:11434/api/generate&quot;</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;model&quot;</span>: model,</span><br><span class="line">        <span class="string">&quot;prompt&quot;</span>: prompt,</span><br><span class="line">        <span class="string">&quot;stream&quot;</span>: <span class="literal">True</span>  <span class="comment"># 启用流式输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response = requests.post(url, json=payload, stream=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> response.iter_lines():</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            data = json.loads(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;response&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="built_in">print</span>(data[<span class="string">&quot;response&quot;</span>], end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> data.get(<span class="string">&quot;done&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    prompt = <span class="string">&quot;请详细解释什么是深度学习，以及它与传统机器学习的区别&quot;</span></span><br><span class="line">    stream_ollama(prompt)</span><br></pre></td></tr></table></figure><h2 id="3-多轮交流示例"><a href="#3-多轮交流示例" class="headerlink" title="3. 多轮交流示例"></a>3. 多轮交流示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stream_ollama_chat</span>(<span class="params">messages, model=<span class="string">&quot;gemma3:1b&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    支持多轮对话的Ollama聊天函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        messages: 对话历史列表，每个元素包含role和content</span></span><br><span class="line"><span class="string">        model: 使用的模型名称</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = <span class="string">&quot;http://localhost:11434/api/chat&quot;</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;model&quot;</span>: model,</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: messages,</span><br><span class="line">        <span class="string">&quot;stream&quot;</span>: <span class="literal">True</span>  <span class="comment"># 启用流式输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 常用参数配置示例</span></span><br><span class="line">    options = &#123;</span><br><span class="line">        <span class="string">&quot;temperature&quot;</span>: <span class="number">0.7</span>,  <span class="comment"># 控制输出的随机性，值越高越随机</span></span><br><span class="line">        <span class="string">&quot;top_p&quot;</span>: <span class="number">0.9</span>,  <span class="comment"># nucleus sampling参数</span></span><br><span class="line">        <span class="string">&quot;top_k&quot;</span>: <span class="number">40</span>,  <span class="comment"># top-k采样参数</span></span><br><span class="line">        <span class="string">&quot;num_ctx&quot;</span>: <span class="number">2048</span>,  <span class="comment"># 上下文窗口大小</span></span><br><span class="line">        <span class="string">&quot;num_predict&quot;</span>: <span class="number">512</span>,  <span class="comment"># 最大生成token数</span></span><br><span class="line">        <span class="string">&quot;repeat_penalty&quot;</span>: <span class="number">1.1</span>,  <span class="comment"># 重复惩罚</span></span><br><span class="line">        <span class="string">&quot;seed&quot;</span>: <span class="number">42</span>  <span class="comment"># 随机种子，设置固定值可获得可重复结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果提供了options参数，则添加到请求中</span></span><br><span class="line">    <span class="keyword">if</span> options:</span><br><span class="line">        payload[<span class="string">&quot;options&quot;</span>] = options</span><br><span class="line"></span><br><span class="line">    response = requests.post(url, json=payload, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    full_response = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> response.iter_lines():</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = json.loads(line)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;message&quot;</span> <span class="keyword">in</span> data <span class="keyword">and</span> data[<span class="string">&quot;message&quot;</span>][<span class="string">&quot;role&quot;</span>] == <span class="string">&quot;assistant&quot;</span>:</span><br><span class="line">                    content = data[<span class="string">&quot;message&quot;</span>][<span class="string">&quot;content&quot;</span>]</span><br><span class="line">                    <span class="built_in">print</span>(content, end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                    full_response += content</span><br><span class="line">                <span class="keyword">if</span> data.get(<span class="string">&quot;done&quot;</span>, <span class="literal">False</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> json.JSONDecodeError:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 换行</span></span><br><span class="line">    <span class="keyword">return</span> full_response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_with_ollama</span>(<span class="params">model=<span class="string">&quot;gemma3:1b&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多轮对话交互函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    messages = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始多轮对话（输入 &#x27;quit&#x27; 或 &#x27;exit&#x27; 退出）:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        user_input = <span class="built_in">input</span>(<span class="string">&quot;\n你: &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user_input.lower() <span class="keyword">in</span> [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;对话结束&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加用户消息到对话历史</span></span><br><span class="line">        messages.append(&#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: user_input</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;AI: &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment"># 获取AI回复</span></span><br><span class="line">        ai_response = stream_ollama_chat(messages, model)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加AI回复到对话历史</span></span><br><span class="line">        messages.append(&#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: ai_response</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 单次对话示例</span></span><br><span class="line">    <span class="comment"># messages = [</span></span><br><span class="line">    <span class="comment">#     &#123;</span></span><br><span class="line">    <span class="comment">#         &quot;role&quot;: &quot;user&quot;,</span></span><br><span class="line">    <span class="comment">#         &quot;content&quot;: &quot;请详细解释什么是深度学习，以及它与传统机器学习的区别&quot;</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># ]</span></span><br><span class="line">    <span class="comment"># print(&quot;单次对话示例:&quot;)</span></span><br><span class="line">    <span class="comment"># stream_ollama_chat(messages)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多轮对话示例</span></span><br><span class="line">    chat_with_ollama()</span><br></pre></td></tr></table></figure><h1 id="附录：通过Huggingface下载大模型并本地运行"><a href="#附录：通过Huggingface下载大模型并本地运行" class="headerlink" title="附录：通过Huggingface下载大模型并本地运行"></a>附录：通过Huggingface下载大模型并本地运行</h1><ol><li>Huggingface<br>(1) 代码调用直接下载（均因网络问题失败，打开vpn也不行）<br>(2) 手动下载<br>在<a href="https://huggingface.co/">https://huggingface.co/</a>找到相应模型下载目录下所有文件<br><img src="/images/01_3.png" alt="在这里插入图片描述"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"># 模型名称和本地保存路径</span><br><span class="line">model_name = <span class="string">&quot;deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B&quot;</span></span><br><span class="line">model_save_path = <span class="string">&quot;./DeepSeek-R1-Distill-Qwen-1.5B&quot;</span>  # 自定义本地保存路径</span><br><span class="line"></span><br><span class="line"># 创建保存目录（如果不存在）</span><br><span class="line">os.makedirs(model_save_path, exist_ok=True)</span><br><span class="line"></span><br><span class="line"># 加载并保存tokenizer</span><br><span class="line"># tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line"># tokenizer.save_pretrained(model_save_path)</span><br><span class="line"># print(f<span class="string">&quot;Tokenizer已保存至: &#123;model_save_path&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 加载并保存模型</span><br><span class="line"># model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">#     model_name,</span><br><span class="line">#     device_map=<span class="string">&quot;auto&quot;</span>  # 自动分配设备（优先GPU）</span><br><span class="line"># )</span><br><span class="line"># model.save_pretrained(model_save_path)</span><br><span class="line"># print(f<span class="string">&quot;模型已保存至: &#123;model_save_path&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 配置量化参数</span><br><span class="line">quantization_config = BitsAndBytesConfig(load_in_8bit=True)</span><br><span class="line"></span><br><span class="line"># 后续可直接从本地加载（取消注释即可使用）</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_save_path)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_save_path,</span><br><span class="line">                                             quantization_config=quantization_config,</span><br><span class="line">                                             device_map=<span class="string">&quot;auto&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;模型已加载至: &#123;model.device&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 对话示例</span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;解释一下勾股定理&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line">inputs = tokenizer.apply_chat_template(messages,</span><br><span class="line">                                       add_generation_prompt=True,</span><br><span class="line">                                       tokenize=True,</span><br><span class="line">                                       return_dict=True,</span><br><span class="line">                                       return_tensors=<span class="string">&quot;pt&quot;</span>).to(model.device)</span><br><span class="line"></span><br><span class="line">outputs = model.generate(**inputs, max_new_tokens=<span class="number">50000</span>)</span><br><span class="line"># 解码并打印生成的回复（排除输入部分）</span><br><span class="line">print(tokenizer.decode(outputs[<span class="number">0</span>][inputs[<span class="string">&quot;input_ids&quot;</span>].shape[-<span class="number">1</span>]:], skip_special_tokens=True))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL】MySQL基础教程</title>
      <link href="/2025/07/19/10_MySQL_base/"/>
      <url>/2025/07/19/10_MySQL_base/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装与登录"><a href="#一、安装与登录" class="headerlink" title="一、安装与登录"></a>一、安装与登录</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>windows下载链接：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a>，默认安装</p><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h3><p>打开cmd，cd进入到安装路径，然后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码后进入 MySQL 命令行。</p><h2 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mydatabase;</span><br></pre></td></tr></table></figure><h3 id="2-查询已创建数据库"><a href="#2-查询已创建数据库" class="headerlink" title="2. 查询已创建数据库"></a>2. 查询已创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><h3 id="3-选择数据库"><a href="#3-选择数据库" class="headerlink" title="3. 选择数据库"></a>3. 选择数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE mydatabase;</span><br></pre></td></tr></table></figure><h3 id="4-查看当前使用数据库"><a href="#4-查看当前使用数据库" class="headerlink" title="4. 查看当前使用数据库"></a>4. 查看当前使用数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><h3 id="5-创建表"><a href="#5-创建表" class="headerlink" title="5. 创建表"></a>5. 创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 用户表</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  name VARCHAR(50) NOT NULL,</span><br><span class="line">  email VARCHAR(100) UNIQUE,</span><br><span class="line">  age INT CHECK (age &gt;= 18),</span><br><span class="line">  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE orders (</span><br><span class="line">  order_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  user_id INT,</span><br><span class="line">  product_name VARCHAR(100),</span><br><span class="line">  amount DECIMAL(10, 2),</span><br><span class="line">  order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  FOREIGN KEY (user_id) REFERENCES users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="6-查询所有表"><a href="#6-查询所有表" class="headerlink" title="6. 查询所有表"></a>6. 查询所有表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h3 id="7-插入数据"><a href="#7-插入数据" class="headerlink" title="7. 插入数据"></a>7. 插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 向 users 表插入数据</span><br><span class="line">INSERT INTO users (name, email, age)</span><br><span class="line">VALUES </span><br><span class="line">  (&#x27;John Doe&#x27;, &#x27;john@example.com&#x27;, 25),</span><br><span class="line">  (&#x27;Jane Smith&#x27;, &#x27;jane@example.com&#x27;, 30);</span><br><span class="line"></span><br><span class="line">-- 向 orders 表插入数据</span><br><span class="line">INSERT INTO orders (user_id, product_name, amount)</span><br><span class="line">VALUES </span><br><span class="line">  (1, &#x27;Laptop&#x27;, 999.99),</span><br><span class="line">  (1, &#x27;Mouse&#x27;, 29.99),</span><br><span class="line">  (2, &#x27;Keyboard&#x27;, 59.99);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_17.png" alt="在这里插入图片描述"><br> <img src="/2025/07/19/10_MySQL_base/img_13.png" alt="在这里插入图片描述"></p><h3 id="8-查询数据"><a href="#8-查询数据" class="headerlink" title="8. 查询数据"></a>8. 查询数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有用户</span><br><span class="line">SELECT * FROM users;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 John 的订单</span><br><span class="line">SELECT * </span><br><span class="line">FROM orders </span><br><span class="line">WHERE user_id = (SELECT id FROM users WHERE name = &#x27;John Doe&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_1.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 联合查询用户及其订单</span><br><span class="line">SELECT users.name, orders.product_name, orders.amount</span><br><span class="line">FROM users</span><br><span class="line">JOIN orders ON users.id = orders.user_id;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_6.png" alt="在这里插入图片描述"></p><h3 id="9-更新数据"><a href="#9-更新数据" class="headerlink" title="9. 更新数据"></a>9. 更新数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 将 John 的年龄更新为 26</span><br><span class="line">UPDATE users </span><br><span class="line">SET age = 26 </span><br><span class="line">WHERE name = &#x27;John Doe&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_15.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 将所有订单金额增加 10%</span><br><span class="line">UPDATE orders </span><br><span class="line">SET amount = amount * 1.1;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_2.png" alt="在这里插入图片描述"></p><h3 id="10-删除数据"><a href="#10-删除数据" class="headerlink" title="10. 删除数据"></a>10. 删除数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 删除 Jane 的订单</span><br><span class="line">DELETE FROM orders </span><br><span class="line">WHERE user_id = (SELECT id FROM users WHERE name = &#x27;Jane Smith&#x27;);</span><br><span class="line"></span><br><span class="line">-- 删除 Jane 用户</span><br><span class="line">DELETE FROM users </span><br><span class="line">WHERE name = &#x27;Jane Smith&#x27;;</span><br></pre></td></tr></table></figure><h2 id="三、数据类型与约束"><a href="#三、数据类型与约束" class="headerlink" title="三、数据类型与约束"></a>三、数据类型与约束</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><p>MySQL 支持多种数据类型，常见的有：</p><ul><li>数值类型: <code>INT</code>, <code>FLOAT</code>, <code>DOUBLE</code>, <code>DECIMAL</code></li><li>字符串类型: <code>VARCHAR</code>, <code>CHAR</code>, <code>TEXT</code></li><li>日期时间类型: <code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code></li><li>布尔类型: <code>TINYINT(1)</code>（0 表示FALSE，1 表示TRUE）</li></ul><h3 id="2-约束"><a href="#2-约束" class="headerlink" title="2. 约束"></a>2. 约束</h3><p>约束用于确保数据的完整性，常见约束有：</p><ul><li><code>PRIMARY KEY</code>: 唯一标识表中每条记录。</li><li><code>UNIQUE</code>: 确保字段值唯一。</li><li><code>NOT NULL</code>: 字段不能为空。</li><li><code>CHECK</code>: 限制字段值的范围。</li><li><code>FOREIGN KEY</code>: 建立表间关联。</li></ul><h2 id="四、表间关系示例"><a href="#四、表间关系示例" class="headerlink" title="四、表间关系示例"></a>四、表间关系示例</h2><h3 id="1-一对多关系"><a href="#1-一对多关系" class="headerlink" title="1. 一对多关系"></a>1. 一对多关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 部门表（主表）</span><br><span class="line">CREATE TABLE departments (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 员工表（从表）</span><br><span class="line">CREATE TABLE employees (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50),</span><br><span class="line">  department_id INT,</span><br><span class="line">  salary DECIMAL(10, 2),</span><br><span class="line">  FOREIGN KEY (department_id) REFERENCES departments(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入示例数据</span><br><span class="line">INSERT INTO departments (id, name) VALUES (1, &#x27;IT&#x27;), (2, &#x27;HR&#x27;);</span><br><span class="line">INSERT INTO employees (id, name, department_id, salary) </span><br><span class="line">VALUES </span><br><span class="line">  (101, &#x27;Alice&#x27;, 1, 8000),</span><br><span class="line">  (102, &#x27;Bob&#x27;, 1, 7500),</span><br><span class="line">  (103, &#x27;Charlie&#x27;, 2, 6000);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_7.png" alt="在这里插入图片描述"><br> <img src="/2025/07/19/10_MySQL_base/img_16.png" alt="在这里插入图片描述"></p><h3 id="2-多对多关系"><a href="#2-多对多关系" class="headerlink" title="2. 多对多关系"></a>2. 多对多关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 学生表</span><br><span class="line">CREATE TABLE students (</span><br><span class="line">  student_id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 课程表</span><br><span class="line">CREATE TABLE courses (</span><br><span class="line">  course_id INT PRIMARY KEY,</span><br><span class="line">  course_name VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 中间表（学生-课程关联）</span><br><span class="line">CREATE TABLE student_courses (</span><br><span class="line">  student_id INT,</span><br><span class="line">  course_id INT,</span><br><span class="line">  PRIMARY KEY (student_id, course_id),</span><br><span class="line">  FOREIGN KEY (student_id) REFERENCES students(student_id),</span><br><span class="line">  FOREIGN KEY (course_id) REFERENCES courses(course_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入示例数据</span><br><span class="line">INSERT INTO students (student_id, name) VALUES (1, &#x27;David&#x27;), (2, &#x27;Emma&#x27;);</span><br><span class="line">INSERT INTO courses (course_id, course_name) VALUES (1001, &#x27;Math&#x27;), (1002, &#x27;Physics&#x27;);</span><br><span class="line">INSERT INTO student_courses (student_id, course_id) VALUES (1, 1001), (1, 1002), (2, 1001);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_11.png" alt="在这里插入图片描述"><br> <img src="/2025/07/19/10_MySQL_base/img_8.png" alt="在这里插入图片描述"><br> <img src="/2025/07/19/10_MySQL_base/img_12.png" alt="在这里插入图片描述"></p><h2 id="五、高级查询示例"><a href="#五、高级查询示例" class="headerlink" title="五、高级查询示例"></a>五、高级查询示例</h2><h3 id="1-连接查询"><a href="#1-连接查询" class="headerlink" title="1. 连接查询"></a>1. 连接查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询每个部门的员工数量</span><br><span class="line">SELECT departments.name, COUNT(employees.id) AS employee_count</span><br><span class="line">FROM departments</span><br><span class="line">LEFT JOIN employees ON departments.id = employees.department_id</span><br><span class="line">GROUP BY departments.name;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_5.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询选修了 Math 课程的学生</span><br><span class="line">SELECT students.name</span><br><span class="line">FROM students</span><br><span class="line">JOIN student_courses ON students.student_id = student_courses.student_id</span><br><span class="line">JOIN courses ON student_courses.course_id = courses.course_id</span><br><span class="line">WHERE courses.course_name = &#x27;Math&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_14.png" alt="在这里插入图片描述"></p><h3 id="2-子查询"><a href="#2-子查询" class="headerlink" title="2. 子查询"></a>2. 子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资高于平均工资的员工</span><br><span class="line">SELECT name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (SELECT AVG(salary) FROM employees);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_3.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询没有订单的用户</span><br><span class="line">SELECT name</span><br><span class="line">FROM users</span><br><span class="line">WHERE id NOT IN (SELECT DISTINCT user_id FROM orders);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_10.png" alt="在这里插入图片描述"></p><h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3. 聚合函数"></a>3. 聚合函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 统计每个部门的总工资和平均工资</span><br><span class="line">SELECT </span><br><span class="line">  department_id,</span><br><span class="line">  SUM(salary) AS total_salary,</span><br><span class="line">  AVG(salary) AS average_salary,</span><br><span class="line">  COUNT(*) AS employee_count</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_4.png" alt="在这里插入图片描述"></p><h3 id="4-分组与过滤"><a href="#4-分组与过滤" class="headerlink" title="4. 分组与过滤"></a>4. 分组与过滤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询订单总金额超过 1000 的用户</span><br><span class="line">SELECT </span><br><span class="line">  users.name,</span><br><span class="line">  SUM(orders.amount) AS total_spent</span><br><span class="line">FROM users</span><br><span class="line">JOIN orders ON users.id = orders.user_id</span><br><span class="line">GROUP BY users.id</span><br><span class="line">HAVING SUM(orders.amount) &gt; 1000;</span><br></pre></td></tr></table></figure><p><img src="/2025/07/19/10_MySQL_base/img_9.png" alt="在这里插入图片描述"></p><h2 id="六、用户权限管理"><a href="#六、用户权限管理" class="headerlink" title="六、用户权限管理"></a>六、用户权限管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建只读用户</span><br><span class="line">CREATE USER &#x27;readonly_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">GRANT SELECT ON mydatabase.* TO &#x27;readonly_user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">-- 创建读写用户（仅限 users 表）</span><br><span class="line">CREATE USER &#x27;user_manager&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">GRANT SELECT, INSERT, UPDATE, DELETE ON mydatabase.users TO &#x27;user_manager&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><h2 id="七、备份与恢复"><a href="#七、备份与恢复" class="headerlink" title="七、备份与恢复"></a>七、备份与恢复</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 备份单个表</span><br><span class="line">mysqldump -u root -p mydatabase users &gt; users_backup.sql</span><br><span class="line"></span><br><span class="line"># 备份多个表</span><br><span class="line">mysqldump -u root -p mydatabase users orders &gt; data_backup.sql</span><br><span class="line"></span><br><span class="line"># 恢复表（需先创建数据库）</span><br><span class="line">mysql -u root -p mydatabase &lt; data_backup.sql</span><br></pre></td></tr></table></figure><p>命令拆解：</p><ul><li><code>mysqldump</code>：备份工具主命令</li><li><code>-u root</code>：指定连接数据库的用户（这里是 root）</li><li><code>-p</code>：提示输入用户密码（执行后会要求输入 root 的密码）</li><li><code>mydatabase</code>：指定要备份的数据库名</li><li><code>users</code>：指定要备份的表名（仅备份该表）</li><li><code>users_backup.sql</code>：将备份内容输出到 users_backup.sql 文件（重定向输出）</li></ul><p>备份原理：</p><ul><li>mysqldump 通过 root 用户连接 MySQL 服务器，验证密码后访问 mydatabase 数据库；</li><li>读取 users 表的元信息（结构）：生成 CREATE TABLE users (…) 语句（包含字段、类型、约束等）；</li><li>读取 users 表的所有数据：生成 INSERT INTO users (…) VALUES (…) 语句（一行数据对应一条或批量 INSERT）；</li><li>为了避免恢复时的冲突，会自动添加 DROP TABLE IF EXISTS users;（如果表已存在则先删除）；</li><li>将上述所有 SQL 语句通过 &gt; 重定向到 users_backup.sql 文件，完成备份。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】ArrayList 和 LinkedList 详解</title>
      <link href="/2025/06/15/08_Java_arraylist_linkedlist/"/>
      <url>/2025/06/15/08_Java_arraylist_linkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据结构与核心特性"><a href="#一、数据结构与核心特性" class="headerlink" title="一、数据结构与核心特性"></a>一、数据结构与核心特性</h1><h2 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h2><ul><li>数据结构：基于动态数组实现，元素存储在连续内存中。</li><li>核心特性：<br>– 通过索引随机访问元素，时间复杂度 O (1)。<br>– 扩容机制：容量不足时新建数组（原容量的 1.5 倍）并复制元素。<br>– 尾部添加 &#x2F; 删除效率高（O (1)），中间操作需移动元素（O (n)）。<br>– 不直接支持 poll&#x2F;offer，需借助 ArrayDeque 或 LinkedList 包装。</li></ul><h2 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h2><ul><li>数据结构：双向链表，每个节点包含前驱、后继指针和元素值。</li><li>核心特性：<br>– 任意位置插入 &#x2F; 删除仅需修改指针（O (1)），但随机访问需遍历（O (n)）。<br>– 实现 Deque 接口，原生支持 poll&#x2F;offer 等队列操作。<br>– 无容量限制，节点动态分配内存，内存占用高于 ArrayList。</li></ul><h2 id="二、核心方法对比"><a href="#二、核心方法对比" class="headerlink" title="二、核心方法对比"></a>二、核心方法对比</h2><table><thead><tr><th>操作类型</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>构造</td><td><code>new ArrayList&lt;&gt;()</code>（初始容量 10）</td><td><code>new LinkedList&lt;&gt;()</code></td></tr><tr><td>添加元素</td><td><code>add(E e)</code>（尾部，O(1)）<br><code>add(index, e)</code>（中间，O(n)）</td><td><code>add(e)</code>（尾部，O(1)）<br><code>addFirst(e)</code> &#x2F; <code>addLast(e)</code>（O(1)）</td></tr><tr><td>删除元素</td><td><code>remove(index)</code>（O(n)）</td><td><code>removeFirst()</code> &#x2F; <code>removeLast()</code>（O(1)）</td></tr><tr><td>随机访问</td><td><code>get(index)</code>（O(1)）</td><td><code>get(index)</code>（O(n)，需遍历链表）</td></tr><tr><td>队列操作（poll）</td><td>需包装为 <code>ArrayDeque</code>，本质数组操作</td><td><code>poll()</code>（取头部，O(1)）<br><code>pollFirst()</code> &#x2F; <code>pollLast()</code>（O(1)）</td></tr><tr><td>队列操作（offer）</td><td>需包装为 <code>ArrayDeque</code>，尾部添加 O(1)</td><td><code>offer(e)</code>（尾部，O(1)）<br><code>offerFirst(e)</code> &#x2F; <code>offerLast(e)</code>（O(1)）</td></tr></tbody></table><h2 id="三、poll-和-offer-方法详解"><a href="#三、poll-和-offer-方法详解" class="headerlink" title="三、poll 和 offer 方法详解"></a>三、poll 和 offer 方法详解</h2><h3 id="1-方法定义与功能"><a href="#1-方法定义与功能" class="headerlink" title="1. 方法定义与功能"></a>1. 方法定义与功能</h3><ul><li>poll()：获取并移除集合头部元素，空集合返回 null（区别于 remove() 的异常）。</li><li>offer(E e)：添加元素到集合，成功返回 true（LinkedList 无容量限制，始终成功）。</li></ul><h3 id="2-LinkedList-中的队列操作"><a href="#2-LinkedList-中的队列操作" class="headerlink" title="2. LinkedList 中的队列操作"></a>2. LinkedList 中的队列操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">deque.offer(<span class="string">&quot;A&quot;</span>);       <span class="comment">// 尾部添加，等价于 addLast()</span></span><br><span class="line">deque.offerFirst(<span class="string">&quot;B&quot;</span>);  <span class="comment">// 头部添加</span></span><br><span class="line">deque.offerLast(<span class="string">&quot;C&quot;</span>);   <span class="comment">// 尾部添加，等价于 offer()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并移除元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">head</span> <span class="operator">=</span> deque.poll();      <span class="comment">// 取头部（&quot;B&quot;），队列变为 [&quot;A&quot;, &quot;C&quot;]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tail</span> <span class="operator">=</span> deque.pollLast();  <span class="comment">// 取尾部（&quot;C&quot;），队列变为 [&quot;A&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空集合处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> deque.poll(); <span class="comment">// 返回 null，不抛异常</span></span><br></pre></td></tr></table></figure><h3 id="3-ArrayList-实现队列操作（需适配器）"><a href="#3-ArrayList-实现队列操作（需适配器）" class="headerlink" title="3. ArrayList 实现队列操作（需适配器）"></a>3. ArrayList 实现队列操作（需适配器）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐方式：使用 ArrayDeque 包装 ArrayList</span></span><br><span class="line">Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">queue.offer(<span class="number">4</span>);   <span class="comment">// 尾部添加，队列变为 [1,2,3,4]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 取头部（1），队列变为 [2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐方式：用 LinkedList 包装 ArrayList（性能差）</span></span><br><span class="line">Queue&lt;Integer&gt; arrayListQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">arrayListQueue.offer(<span class="number">5</span>); <span class="comment">// 内部通过链表添加，非数组直接操作</span></span><br></pre></td></tr></table></figure><h2 id="四、性能与适用场景"><a href="#四、性能与适用场景" class="headerlink" title="四、性能与适用场景"></a>四、性能与适用场景</h2><h3 id="1-性能对比"><a href="#1-性能对比" class="headerlink" title="1. 性能对比"></a>1. 性能对比</h3><table><thead><tr><th>操作</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>尾部添加</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n) (移动元素)</td><td>O(1) (修改指针)</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n) (遍历链表)</td></tr><tr><td>poll&#x2F;offer 头部</td><td>需适配器，O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><ul><li>选 ArrayList 的场景：<ul><li>频繁随机访问（如 get(index)）。</li><li>尾部添加 &#x2F; 删除为主（如日志记录）。</li><li>数据量可预测，避免频繁扩容。</li></ul></li><li>选 LinkedList 的场景：<ul><li>频繁在头部 &#x2F; 中间插入 &#x2F; 删除（如任务队列）。</li><li>需要使用 poll&#x2F;offer 等双端队列操作。</li><li>数据量不确定，不希望有扩容开销。</li></ul></li></ul><h2 id="五、代码示例：综合应用"><a href="#五、代码示例：综合应用" class="headerlink" title="五、代码示例：综合应用"></a>五、代码示例：综合应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListComparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// === ArrayList 作为普通列表 ===</span></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList 随机访问：&quot;</span> + arrayList.get(<span class="number">1</span>)); <span class="comment">// 输出：香蕉</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// === LinkedList 作为队列 ===</span></span><br><span class="line">        Queue&lt;String&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        taskQueue.offer(<span class="string">&quot;数据采集&quot;</span>);</span><br><span class="line">        taskQueue.offer(<span class="string">&quot;模型训练&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;队列处理顺序：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;- &quot;</span> + taskQueue.poll()); <span class="comment">// 按添加顺序输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// === LinkedList 作为栈 ===</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.offerFirst(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">        stack.offerFirst(<span class="string">&quot;CSS&quot;</span>);</span><br><span class="line">        stack.offerFirst(<span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n栈弹出顺序：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;- &quot;</span> + stack.pollFirst()); <span class="comment">// 后入先出</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// === ArrayList 实现队列（借助 ArrayDeque）===</span></span><br><span class="line">        Deque&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(Arrays.asList(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        arrayQueue.offer(<span class="number">30</span>); <span class="comment">// 尾部添加</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nArrayDeque 包装 ArrayList 队列：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!arrayQueue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;- &quot;</span> + arrayQueue.poll()); <span class="comment">// 10, 20, 30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结与注意事项"><a href="#六、总结与注意事项" class="headerlink" title="六、总结与注意事项"></a>六、总结与注意事项</h2><h3 id="1-数据结构决定性能："><a href="#1-数据结构决定性能：" class="headerlink" title="1. 数据结构决定性能："></a>1. 数据结构决定性能：</h3><ul><li>ArrayList 适合 “读多写少” 场景，尤其随机访问频繁时。</li><li>LinkedList 适合 “写多读少” 场景，尤其需要队列 &#x2F; 栈操作时。</li></ul><h3 id="2-队列操作的最佳实践："><a href="#2-队列操作的最佳实践：" class="headerlink" title="2. 队列操作的最佳实践："></a>2. 队列操作的最佳实践：</h3><ul><li>优先使用 LinkedList 或 ArrayDeque 实现队列 &#x2F; 栈，而非包装 ArrayList。</li><li>ArrayDeque 的性能通常优于 LinkedList，因数组连续存储减少内存跳转。</li></ul><h3 id="3-线程安全："><a href="#3-线程安全：" class="headerlink" title="3. 线程安全："></a>3. 线程安全：</h3><ul><li>两者均非线程安全，多线程环境需用 Collections.synchronizedList() 包装或使用 CopyOnWriteArrayList。</li></ul><p>通过理解两者的底层实现与方法特性，可根据业务场景（如数据访问模式、操作频率）选择更合适的集合类，优化程序效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】集合类</title>
      <link href="/2025/05/23/07_Java_collection%20/"/>
      <url>/2025/05/23/07_Java_collection%20/</url>
      
        <content type="html"><![CDATA[<p>Java 集合类是用于存储和操作数据的核心工具，主要分为Collection和Map两大接口体系，每个接口下有多种实现类。以下是 Java 集合类的完整介绍：</p><h1 id="一、集合框架核心接口"><a href="#一、集合框架核心接口" class="headerlink" title="一、集合框架核心接口"></a>一、集合框架核心接口</h1><h2 id="1-Collection-接口"><a href="#1-Collection-接口" class="headerlink" title="1. Collection 接口"></a>1. Collection 接口</h2><p>集合体系的根接口，定义了添加、删除、遍历等基本操作</p><p>三个主要子接口：</p><ul><li>List：有序、可重复元素的集合，支持索引访问</li><li>Set：唯一元素集合，不允许重复值</li><li>Queue：按特定顺序（如 FIFO）处理元素的集合</li></ul><h2 id="2-Map-接口"><a href="#2-Map-接口" class="headerlink" title="2. Map 接口"></a>2. Map 接口</h2><p>以键值对（Key-Value）形式存储数据，键唯一</p><h1 id="二、常用集合类及其特点"><a href="#二、常用集合类及其特点" class="headerlink" title="二、常用集合类及其特点"></a>二、常用集合类及其特点</h1><h2 id="1-List-实现类"><a href="#1-List-实现类" class="headerlink" title="1. List 实现类"></a>1. List 实现类</h2><table><thead><tr><th>类名</th><th>特点</th></tr></thead><tbody><tr><td>ArrayList</td><td>基于动态数组实现，随机访问高效，中间位置增删效率低</td></tr><tr><td>LinkedList</td><td>基于双向链表实现，增删效率高，随机访问效率低</td></tr><tr><td>Vector</td><td>线程安全，性能低于 ArrayList，已逐渐被淘汰</td></tr></tbody></table><h2 id="2-Set-实现类"><a href="#2-Set-实现类" class="headerlink" title="2. Set 实现类"></a>2. Set 实现类</h2><table><thead><tr><th>类名</th><th>特点</th></tr></thead><tbody><tr><td>HashSet</td><td>基于哈希表（底层为 HashMap），不保证元素顺序</td></tr><tr><td>LinkedHashSet</td><td>继承 HashSet，用链表维护插入顺序，插入和访问顺序一致</td></tr><tr><td>TreeSet</td><td>基于红黑树实现，元素自然排序或按比较器排序</td></tr></tbody></table><h2 id="3-Queue-实现类"><a href="#3-Queue-实现类" class="headerlink" title="3. Queue 实现类"></a>3. Queue 实现类</h2><table><thead><tr><th>类名</th><th>特点</th></tr></thead><tbody><tr><td>LinkedList</td><td>实现 Deque 接口，可作为双向队列使用</td></tr><tr><td>PriorityQueue</td><td>基于堆结构，按优先级排序，不允许 null 元素</td></tr><tr><td>ArrayDeque</td><td>基于数组的双端队列，不允许 null 元素</td></tr></tbody></table><h2 id="4-Map-实现类"><a href="#4-Map-实现类" class="headerlink" title="4. Map 实现类"></a>4. Map 实现类</h2><table><thead><tr><th>类名</th><th>特点</th></tr></thead><tbody><tr><td>HashMap</td><td>基于哈希表，不保证顺序，允许键值为 null</td></tr><tr><td>LinkedHashMap</td><td>继承 HashMap，用链表维护插入顺序或访问顺序</td></tr><tr><td>TreeMap</td><td>基于红黑树，按键排序，不允许键为 null</td></tr><tr><td>Hashtable</td><td>线程安全，性能低于 HashMap，不允许键值为 null</td></tr></tbody></table><h1 id="三、线程安全的集合类"><a href="#三、线程安全的集合类" class="headerlink" title="三、线程安全的集合类"></a>三、线程安全的集合类</h1><ul><li>同步包装类</li></ul><p>通过Collections.synchronizedXXX()转换非线程安全集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; syncList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><ul><li>并发集合类（java.util.concurrent 包）</li></ul><p>ConcurrentHashMap：分段锁实现的线程安全 HashMap，性能优于 Hashtable<br>CopyOnWriteArrayList：写操作时创建副本的线程安全 ArrayList</p><h1 id="四、集合常用操作示例"><a href="#四、集合常用操作示例" class="headerlink" title="四、集合常用操作示例"></a>四、集合常用操作示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ============== List 操作示例 ==============</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===== List 操作 =====&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加后的List: &quot;</span> + list); <span class="comment">// [apple, banana, cherry]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基础查询（可能抛出异常）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;索引1的元素: &quot;</span> + list.get(<span class="number">1</span>)); <span class="comment">// banana</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全查询（带默认值）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;索引10的元素: &quot;</span> + getOrDefault(list, <span class="number">10</span>, <span class="string">&quot;default&quot;</span>)); <span class="comment">// default</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断元素是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含apple: &quot;</span> + list.contains(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含grape: &quot;</span> + list.contains(<span class="string">&quot;grape&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历元素</span></span><br><span class="line">        System.out.print(<span class="string">&quot;遍历方式1: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String fruit : list) &#123;</span><br><span class="line">            System.out.print(fruit + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">&quot;\n遍历方式2: &quot;</span>);</span><br><span class="line">        list.forEach(fruit -&gt; System.out.print(fruit + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ============== Set 操作示例 ==============</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n===== Set 操作 =====&quot;</span>);</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">20</span>); <span class="comment">// 重复元素会被忽略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;添加后的Set: &quot;</span> + set); <span class="comment">// [10, 20]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基础查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Set大小: &quot;</span> + set.size()); <span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查询带默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> set.contains(<span class="number">20</span>) ? <span class="number">20</span> : -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;存在的值: &quot;</span> + value); <span class="comment">// 20</span></span><br><span class="line">        </span><br><span class="line">        value = set.contains(<span class="number">40</span>) ? <span class="number">40</span> : -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在的值: &quot;</span> + value); <span class="comment">// -1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历元素</span></span><br><span class="line">        System.out.print(<span class="string">&quot;遍历Set: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer num : set) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ============== Map 操作示例 ==============</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n===== Map 操作 =====&quot;</span>);</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加后的Map: &quot;</span> + map); <span class="comment">// &#123;one=1, two=2, three=3&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基础查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;键two对应的值: &quot;</span> + map.get(<span class="string">&quot;two&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全查询（带默认值）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> map.get(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键four的值（无默认值）: &quot;</span> + val); <span class="comment">// null</span></span><br><span class="line">        </span><br><span class="line">        val = map.getOrDefault(<span class="string">&quot;four&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键four的值（带默认值）: &quot;</span> + val); <span class="comment">// 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用computeIfAbsent初始化默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;four&quot;</span>, k -&gt; <span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;键four的值: &quot;</span> + count); <span class="comment">// 4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ============== Stream 操作示例 ==============</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== Stream 操作 =====&quot;</span>);</span><br><span class="line">        <span class="comment">// 查找第一个以&quot;b&quot;开头的元素（基础方式）</span></span><br><span class="line">        Optional&lt;String&gt; resultOpt = list.stream()</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">            .findFirst();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resultOpt.isPresent()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到的元素: &quot;</span> + resultOpt.get()); <span class="comment">// banana</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到匹配元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找第一个以&quot;z&quot;开头的元素（带默认值）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream()</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>))</span><br><span class="line">            .findFirst()</span><br><span class="line">            .orElse(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到的元素: &quot;</span> + result); <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义工具方法：获取List元素，不存在时返回默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getOrDefault</span><span class="params">(List&lt;T&gt; list, <span class="type">int</span> index, T defaultValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span> || index &lt; <span class="number">0</span> || index &gt;= list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、字典（Map）遍历"><a href="#五、字典（Map）遍历" class="headerlink" title="五、字典（Map）遍历"></a>五、字典（Map）遍历</h1><h2 id="1-遍历键值对（EntrySet）"><a href="#1-遍历键值对（EntrySet）" class="headerlink" title="1. 遍历键值对（EntrySet）"></a>1. 遍历键值对（EntrySet）</h2><p>这是最高效的遍历方式，尤其适合需要同时访问键和值的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;cherry&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for-each循环遍历EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Iterator（适合需要在遍历中删除元素的场景）</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getValue() == <span class="number">2</span>) &#123;</span><br><span class="line">        iterator.remove(); <span class="comment">// 安全删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单独遍历键（KeySet）"><a href="#2-单独遍历键（KeySet）" class="headerlink" title="2. 单独遍历键（KeySet）"></a>2. 单独遍历键（KeySet）</h2><p>如果只需要访问键，可以使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用for-each循环遍历键</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + key);</span><br><span class="line">    <span class="comment">// 如果需要值，可以通过map.get(key)获取，但效率稍低</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Stream API（Java 8+）</span></span><br><span class="line">map.keySet().stream()</span><br><span class="line">    .forEach(key -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key));</span><br></pre></td></tr></table></figure><h2 id="3-单独遍历值（Values）"><a href="#3-单独遍历值（Values）" class="headerlink" title="3. 单独遍历值（Values）"></a>3. 单独遍历值（Values）</h2><p>若只需要访问值，可采用此方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用for-each循环遍历值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Stream API收集值到List</span></span><br><span class="line">List&lt;Integer&gt; valuesList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br></pre></td></tr></table></figure><h1 id="六、集合选择原则"><a href="#六、集合选择原则" class="headerlink" title="六、集合选择原则"></a>六、集合选择原则</h1><ul><li>有序可重复场景<br>频繁随机访问：选ArrayList<br>频繁增删操作：选LinkedList</li><li>唯一元素场景<br>不要求顺序：选HashSet<br>需插入顺序：选LinkedHashSet<br>需排序：选TreeSet</li><li>键值对存储场景<br>不要求顺序：选HashMap<br>需排序：选TreeMap</li><li>多线程环境<br>优先使用ConcurrentHashMap、CopyOnWriteArrayList等并发集合类</li></ul><h1 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h1><ul><li>迭代修改异常<br>遍历集合时修改结构会触发ConcurrentModificationException，建议使用Iterator.remove()或for-each循环</li><li>哈希方法重写<br>HashMap和HashSet依赖hashCode()和equals()，自定义类需正确重写这两个方法</li><li>性能优化<br>ArrayList可指定初始容量减少扩容开销<br>LinkedList随机访问需遍历链表，避免高频索引操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】数组</title>
      <link href="/2025/05/21/06_Java_array/"/>
      <url>/2025/05/21/06_Java_array/</url>
      
        <content type="html"><![CDATA[<p>在 Java 中，数组是一种存储固定大小同类型元素的数据结构。以下是几种常见的数组创建方法：</p><h2 id="1-声明并初始化数组"><a href="#1-声明并初始化数组" class="headerlink" title="1. 声明并初始化数组"></a>1. 声明并初始化数组</h2><p>使用 new 关键字创建数组，并指定长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明数组变量</span></span><br><span class="line"><span class="type">int</span>[] numbers;</span><br><span class="line"><span class="comment">// 创建数组并分配内存空间</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 长度为5的整数数组</span></span><br></pre></td></tr></table></figure><h2 id="2-声明并直接初始化数组元素"><a href="#2-声明并直接初始化数组元素" class="headerlink" title="2. 声明并直接初始化数组元素"></a>2. 声明并直接初始化数组元素</h2><p>使用花括号 {} 直接初始化数组元素，无需指定长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;; <span class="comment">// 长度为5的整数数组</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;; <span class="comment">// 字符串数组</span></span><br></pre></td></tr></table></figure><h2 id="3-动态初始化数组元素"><a href="#3-动态初始化数组元素" class="headerlink" title="3. 动态初始化数组元素"></a>3. 动态初始化数组元素</h2><p>先创建数组，再逐个赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">300</span>;</span><br></pre></td></tr></table></figure><h2 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4. 多维数组"></a>4. 多维数组</h2><p>创建二维或多维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组 - 3行4列</span></span><br><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化二维数组</span></span><br><span class="line"><span class="type">int</span>[][] matrix2 = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不规则二维数组（每行长度不同）</span></span><br><span class="line"><span class="type">int</span>[][] jaggedArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">jaggedArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">jaggedArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">jaggedArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="5-使用-Arrays-工具类填充数组"><a href="#5-使用-Arrays-工具类填充数组" class="headerlink" title="5. 使用 Arrays 工具类填充数组"></a>5. 使用 Arrays 工具类填充数组</h2><p>使用 java.util.Arrays 类的方法快速填充数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(numbers, <span class="number">10</span>); <span class="comment">// 所有元素填充为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [10, 10, 10, 10, 10]</span></span><br><span class="line">System.out.println(Arrays.toString(numbers));</span><br></pre></td></tr></table></figure><h2 id="6-匿名数组"><a href="#6-匿名数组" class="headerlink" title="6. 匿名数组"></a>6. 匿名数组</h2><p>创建临时数组，无需显式声明变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为方法参数使用</span></span><br><span class="line">printArray(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-数组长度"><a href="#7-数组长度" class="headerlink" title="7. 数组长度"></a>7. 数组长度</h2><p>数组的长度是固定的，通过 length 属性获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(<span class="string">&quot;数组长度: &quot;</span> + numbers.length); <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>数组长度不可变：一旦创建，数组的长度不能改变。</li><li>索引越界：访问数组元素时，索引必须在 0 到 length-1 范围内，否则会抛出 ArrayIndexOutOfBoundsException。</li><li>默认值：数组创建后，元素会被自动初始化为默认值（例如 int 为 0，Object 为 null）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】反射</title>
      <link href="/2025/05/20/05_Java_reflect/"/>
      <url>/2025/05/20/05_Java_reflect/</url>
      
        <content type="html"><![CDATA[<p>在 Java 里，反射是一项强大的功能，它允许程序在运行时对自身进行检查，或者操作程序的内部属性。借助反射，Java 代码能够在运行时动态获取类的信息、创建对象、调用方法以及访问或修改字段，即便在编译时这些类的信息可能并不明确。</p><h1 id="1-反射的核心类"><a href="#1-反射的核心类" class="headerlink" title="1. 反射的核心类"></a>1. 反射的核心类</h1><p>Java 反射的功能主要由以下几个位于java.lang.reflect包和java.lang包中的类实现：</p><ul><li>Class 类：代表一个类，是反射的基础。通过它可以获取类的结构信息。</li><li>Field 类：表示类的成员变量（字段），可用于获取或设置字段值。</li><li>Method 类：表示类的方法，可用于调用方法。</li><li>Constructor 类：表示类的构造方法，可用于创建对象。</li><li>Modifier 类：提供静态方法和常量，用于解析类、方法和字段的修饰符。</li></ul><h1 id="2-获取-Class-对象的三种方式"><a href="#2-获取-Class-对象的三种方式" class="headerlink" title="2. 获取 Class 对象的三种方式"></a>2. 获取 Class 对象的三种方式</h1><p>要使用反射，首先得获取目标类的Class对象，有以下三种常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：通过类名.class获取</span></span><br><span class="line">Class&lt;?&gt; clazz1 = String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过对象.getClass()获取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz2 = str.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：通过全类名的字符串获取（可能抛出ClassNotFoundException）</span></span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="3-反射的常见应用场景"><a href="#3-反射的常见应用场景" class="headerlink" title="3. 反射的常见应用场景"></a>3. 反射的常见应用场景</h1><h2 id="1-动态创建对象"><a href="#1-动态创建对象" class="headerlink" title="(1) 动态创建对象"></a>(1) 动态创建对象</h2><p>可以利用反射调用类的构造方法来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取无参构造方法</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure><h2 id="2-动态调用方法"><a href="#2-动态调用方法" class="headerlink" title="(2) 动态调用方法"></a>(2) 动态调用方法</h2><p>通过反射能够在运行时调用对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(instance, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出 &quot;el&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-访问和修改字段"><a href="#3-访问和修改字段" class="headerlink" title="(3) 访问和修改字段"></a>(3) 访问和修改字段</h2><p>使用反射可以在运行时访问和修改对象的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;fastTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置可访问（针对private字段）</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> (<span class="type">long</span>) field.get(instance);</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改字段值</span></span><br><span class="line">field.set(instance, System.currentTimeMillis());</span><br></pre></td></tr></table></figure><h2 id="4-获取类的结构信息"><a href="#4-获取类的结构信息" class="headerlink" title="(4) 获取类的结构信息"></a>(4) 获取类的结构信息</h2><p>借助反射能够获取类的各种结构信息，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取修饰符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> clazz.getModifiers();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isPublic</span> <span class="operator">=</span> Modifier.isPublic(modifiers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有公共方法</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有声明的字段</span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有接口</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br></pre></td></tr></table></figure><h1 id="4-反射的优缺点"><a href="#4-反射的优缺点" class="headerlink" title="4. 反射的优缺点"></a>4. 反射的优缺点</h1><h2 id="1-优点"><a href="#1-优点" class="headerlink" title="(1) 优点"></a>(1) 优点</h2><ul><li><p>灵活性高：可以在运行时处理未知的类，适用于框架开发，像 Spring、Hibernate 等。</p></li><li><p>可扩展性强：能够通过配置文件动态加载类，无需修改源代码。</p></li><li><p>适合工具开发：IDE、调试器等工具可以利用反射分析类的结构。</p><h2 id="2-缺点"><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a>(2) 缺点</h2></li><li><p>性能开销大：反射操作涉及动态解析，比直接调用效率低。</p></li><li><p>破坏封装性：可以访问和修改私有成员，违背了面向对象的设计原则。</p></li><li><p>安全性风险：可能会导致敏感信息泄露，或者执行不安全的操作。</p><h1 id="5-反射的注意事项"><a href="#5-反射的注意事项" class="headerlink" title="5. 反射的注意事项"></a>5. 反射的注意事项</h1></li><li><p>异常处理：反射操作可能会抛出多种异常，如ClassNotFoundException、NoSuchMethodException、IllegalAccessException等，需要进行适当的处理。</p></li><li><p>性能优化：对于需要频繁调用的反射操作，可以考虑缓存Method、Field等对象。</p></li><li><p>安全性检查：在使用setAccessible(true)时要格外谨慎，避免破坏类的封装性。</p></li><li><p>兼容性问题：反射依赖于类的具体结构，类结构发生变化可能会导致反射代码失效。</p><h1 id="6-反射的典型应用场景"><a href="#6-反射的典型应用场景" class="headerlink" title="6. 反射的典型应用场景"></a>6. 反射的典型应用场景</h1></li><li><p>框架开发：Spring 通过反射实现依赖注入和 AOP。</p></li><li><p>序列化与反序列化：JSON 库（如 Jackson）使用反射将对象转换为 JSON。</p></li><li><p>单元测试：可以测试类的私有方法。</p></li><li><p>注解处理：通过反射读取和处理注解。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】学习笔记</title>
      <link href="/2025/03/15/09_Java_learn/"/>
      <url>/2025/03/15/09_Java_learn/</url>
      
        <content type="html"><![CDATA[<ol><li><p>java基本数据类型是否相等使用”==“运算符；对象是否相等使用equals()方法，使用”==”是判断是否引用到同一个对象上。</p></li><li><p>实例变量（非静态成员变量） 和类变量（静态成员变量） 可以不赋初值，Java 会自动分配默认值；其他类型的变量（尤其是局部变量）必须显式赋值后才能使用。（实例变量是声明在类中、方法之外的非静态变量（不含static修饰），属于对象的属性。当对象被创建时，Java 会自动为实例变量赋予默认值。）</p></li><li><p>同一类所有的实例共享一份静态变量。</p></li><li><p>判断是修改了引用的对象内容还是只修改了方法内的局部引用：（1）查看是否有修改对象内容的方法调用，如果方法中调用了修改对象内容的方法（如append()、replace()、put()等），则可能是修改了对象内容；（2）检查是否直接重新赋值，如果方法中直接对参数重新赋值（如x &#x3D; new…或x &#x3D; other），则只是修改了方法内的局部引用。</p></li><li><p>当try和finally块都有return语句时，finally块中的return会覆盖try块中的return，这是因为finally块在方法返回前执行。</p></li><li><p>final不能修饰接口和抽象类。final修饰的方法不能被重写(Override)，但是可以被重载(Overload)。重写是子类对父类方法的覆盖，而重载是同一个类中方法名相同但参数不同。</p></li><li><p>在Java中，final变量(成员变量)必须在以下位置之一进行初始化：（1）声明时直接初始化；（2）在构造方法中初始化；（3）在初始化块中初始化</p></li><li><p>事务隔离级别是由数据库系统来实现的,这是因为数据库系统负责管理并发事务的执行以及事务之间的隔离性。数据库系统通过锁机制、多版本并发控制(MVCC)等技术来实现不同级别的事务隔离。</p></li><li><p>java中byte类型是转换成int来进行计算的，结果也是int型；int型范围大于byte型，int型数据不能自动转换成byte，故不能直接赋给byte，无法编译。（byte b &#x3D; 1；b&#x3D; b + b；）</p></li><li><p>构造方法的名称与类名相同，构造方法没有返回类型（包括 void）。</p></li><li><p>在Java中synchronized关键字可以用来实现线程同步,通过获取对象的互斥锁来保证同步代码块或同步方法在同一时刻只能被一个线程执行。</p></li><li><p>使用了Thread类创建线程，t.run()是普通方法调用，不会启动新线程，而是在当前主线程中执行，t.start()才会调用新线程。</p></li><li><p>字符串连接操作是从左到右进行的；如果加法运算没有括号，且左边是字符串，则后续的数字会被当作字符串处理；数字之间的加法运算会先执行；括号内的运算具有高优先级，会先计算。<br><img src="/images/09_1.png" alt="在这里插入图片描述"></p></li><li><p>JVM在判定两个class是否相同时，不仅要判断类名是否相同，还要判断加载这个类的类加载器是否相同。这就是”类的唯一性”原则，同一个类文件被不同的类加载器加载，在JVM中会被认为是不同的类。</p></li><li><p>Java的虚拟机确实不支持泛型，所有的泛型在编译阶段都会被擦除，变成普通的类和方法；在编译阶段，所有的泛型类型参数都会被擦除，替换为其边界类型（如果没有指定边界，则替换为Object）；在创建泛型对象时明确指定类型参数是一个很好的实践。这样编译器可以在编译阶段就进行类型检查，避免运行时出现类型转换异常；类型擦除是Java泛型的重要特性，但这并不意味着完全无法获取泛型的类型信息，通过反射机制，我们依然可以在运行时获取到泛型的实际类型参数。</p></li><li><p>volatile关键字的作用</p></li></ol><ul><li>保证内存可见性：当一个线程修改了volatile变量的值，会立即强制将修改后的值刷新到主内存；其他线程读取该变量时，会强制从主内存重新加载最新值，而不是使用工作内存中的缓存副本。</li><li>禁止指令重排序（确保代码执行顺序与预期一致）</li></ul><ol start="17"><li>volatile的局限性</li></ol><ul><li>不保证原子性：volatile只能保证可见性和有序性，但无法保证复合操作的原子性。例如，i++（包含 “读取 - 修改 - 写入” 三步）即使被volatile修饰，在多线程下仍可能出现数据不一致。</li><li>适用场景有限：通常用于状态标记（如示例中的flag）、双重检查锁定等简单场景，复杂的并发控制仍需依赖锁机制。</li></ul><ol start="18"><li>Java中的yield和sleep<br>在 Java 中，yield()和sleep()都是Thread类的静态方法，用于控制线程的执行状态，但它们的作用和行为有显著区别。</li></ol><ul><li>Thread.yield() 方法：让当前正在执行的线程主动放弃 CPU 资源，回到 “就绪状态”，允许其他具有相同优先级的线程获得执行机会。yield()只是向线程调度器发出 “自愿让出 CPU” 的建议，调度器可能忽略该建议（例如，没有其他同优先级线程等待时，当前线程可能立即重新获得 CPU）。无法指定让出 CPU 的时长，完全由调度器决定何时再次执行当前线程。</li><li>Thread.sleep(long millis) 方法：让当前线程暂停执行指定的时间（毫秒），进入 “阻塞状态”，期间不参与 CPU 调度。时间结束后，线程回到 “就绪状态”，等待调度器再次分配 CPU。</li></ul><ol start="19"><li>抽象类可以有构造函数。虽然抽象类不能被实例化，但它的构造函数可以被子类调用(通过super关键字)。</li><li>final 是 Java 中的修饰符，可用于修饰类、方法、变量，作用是限制其 “可变性”，具体行为如下：</li></ol><ul><li>被final修饰的类不能被继承（即无法有子类）</li><li>被final修饰的方法不能被子类重写（Override）</li><li>被final修饰的变量一旦赋值后就不能再修改（即 “常量”）：<ul><li>对于基本数据类型（如int、double）：final保证值不可变</li><li>对于引用数据类型（如对象、数组）：final保证引用地址不可变，但对象内部的属性可以改变</li></ul></li><li>final变量必须在声明时、构造方法中或初始化块中赋值，否则编译报错</li></ul><ol start="21"><li>枚举用于定义一组固定的常量（如季节、星期、状态等），本质是一个继承了java.lang.Enum的类</li></ol><ul><li>枚举的实例是预定义且唯一的，无法在运行时创建新实例</li><li>可包含属性和方法</li><li>枚举中的每个常量本质上都是该枚举类的一个对象，且是单例的（每个常量在内存中只有一个实例）</li></ul><ol start="22"><li>继承与重写案例一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// A类的构造函数，打印&quot;A-&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A类的print方法，打印methodA</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;methodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// B类的构造函数，打印&quot;B-&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B类的print方法，打印methodB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.print();</span><br><span class="line">        System.out.print(<span class="string">&quot;methodB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码展示了Java中的继承和方法重写机制</p><ul><li><p>代码结构</p><ul><li>有三个类：A（父类）、B（子类）和Main（包含主方法）</li><li>类A和类B都包含构造函数和print方法</li><li>Main类中创建了B类的实例并调用了print方法</li></ul></li><li><p>实现原理</p><ul><li><p><strong>继承关系</strong>：类B通过<code>extends A</code>继承了类A，因此B类拥有A类的所有非private成员。</p></li><li><p><strong>构造函数执行顺序</strong>：</p><ul><li>当执行<code>new B()</code>时，首先会调用父类A的构造函数，打印”A-“<ul><li>然后调用子类B的构造函数，打印”B-“</li><li>所以创建B对象时，控制台会输出”A-B-“</li></ul></li></ul></li></ul></li><li><p>方法重写</p><ul><li>B类重写了A类的print方法</li><li>在B类的print方法中，首先通过<code>super.print()</code>调用了父类的print方法，打印”methodA”</li><li>然后打印”methodB”</li><li>所以调用print方法时，控制台会输出”methodAmethodB”</li></ul></li><li><p>执行结果<br>当执行<code>Main</code>类的main方法时，输出结果为：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-B-methodAmethodB</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li><p><strong>构造函数调用顺序</strong>：在Java中，创建子类对象时，会先调用父类的构造函数，然后再调用子类的构造函数。这是为了保证父类部分先被正确初始化。</p></li><li><p><strong>方法重写</strong>：子类可以重写父类的方法，但方法签名（方法名和参数列表）必须相同。重写的方法可以通过<code>super</code>关键字调用父类的版本。</p></li><li><p><strong>多态</strong>：虽然声明的是<code>A a = new B()</code>，但运行时会使用B类的print方法实现，这是Java多态的体现。</p></li><li><p><strong>访问权限</strong>：如果父类的方法是private的，则不会被继承，也就无法被重写。</p></li><li><p><strong>设计考虑</strong>：在这个例子中，子类B在重写print方法时先调用了父类的版本，这通常是一种良好的设计实践，可以保持父类功能的同时扩展子类功能。</p></li></ul></li></ul><ol start="23"><li>子类构造方法必须先调用父类构造方法（显式通过 super(参数) 或隐式默认调用 super()）；普通方法重写后，通过子类对象调用该方法时，会优先执行子类的重写实现（多态特性），父类的方法可以通过 super.方法名() 在子类中被调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
